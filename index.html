<!DOCTYPE html>
<html class="staticrypt-html" lang="de">
<head>
    <meta charset="utf-8"/>
    <title>Home Sweet Home</title> <!-- custom: Protected Page-->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        * {
            font-family: "Kumbh Sans", sans-serif;
            color: white;
            transition-property: all;
            transition-duration: 0.6s;
            transition-timing-function: ease;
        }

        body {
            background-color: #1f1c1b;
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #2a2522;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #443c39;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #c98369;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffbda5;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
            accent-color: #c97f69;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid rgb(128, 128, 128);
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Home Sweet Home</p> <!-- custom: Protected Page-->
                <p></p>
            </div>

            <hr class="staticrypt-hr"/>

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <label for="staticrypt-password"></label>
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Passwort"
                            autofocus
                    />
                    <!-- custom: Password-->
                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Passwort anzeigen"
                            title="Passwort anzeigen"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4="
                    />
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember"/>
                    Nicht erneut fragen
                </label> <!-- custom: Remember me-->

                <input type="submit" class="staticrypt-decrypt-button" value="Weiter"/>
                <!-- custom: DECRYPT-->
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Falsches Passwort!",//custom: "Bad password!",
        templateToggleAltShow = "Passwort anzeigen", //custom: "template_toggle_show",
        templateToggleAltHide = "Passwort ausblenden", //custom: "template_toggle_hide",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb5590c4608a9bda538f097eb5c180bfe7d137a972fa4b1b823a07230e3783f18041859614eed66f9e5a8921a4772cf4e181f5fad643a382d55a15a67d74eaa70046e89a27c8f312c3dfe87354a2dc4a6790b0c7ef7790d0b017cbe9c1a26a71becd3dd0c91b5b8f626c24ea3f344dccab2ffaf4c6c9b5f619cdc5e20ec6a91f78f7f84124a34eaf48535cb0f277991d44770d5f3e6e87a1ec7ea281c2d8b8e38e36dd1db3ba3db36336cb88e0852dc540017b18d69a40e7947c0fb268674f017db235a790f78c9d2f442a4376d5e7e2c762b3e2c403285a77c1a00118916497cde01941aaa569b45bd595e65f3f0a11f3fc46f16f000a67c173d8f307d4ca53a637e1374535a99bf67cc2adecd1a2312e7c92e83a60f5fd4b450df78413f2fa1535443b0eb0d3537f0decedf073b100174c4fff374ab28e4d521374816ff31dc0f85783f2a7bfb482c8bdeda3340e849850869b8b91c18046ed6407606473b60238f0ef84929895c8988b6ee373418d3e695c8cea6a656907609bb013b378d03951ade21d6e0fbef13a0e48710fe7bef7948c25b2da5195952e241a46a3017b78155eac89af7729b60a3e71729b12809c100c80702d9448bc6088f89711c70ef31d03962d1ff0df1c6602763830e0d14d60bcbda5c6055066910f6329b55e1d34e4ad829de96111b2467649db7387a4adf9521105a0cf005764a608d117e2aa8dab1d4d298cff8dedc8ffff48a1fed63acb356d4329804766dffdb94580f8e13e0e13afa3c3cab5f1c4117388e6d9080d07acb340a99899ba07b971af7b31cf2caca0417416948fbda74ba2bb1ce340e11191e9edc54c4b60fbbce3c4974ab4ba4189ce692724b4b6523cc68cdb351e8e2c7f444d7eb10bad7384cc4b4b9ac2f5907746e1e3fe15a67e1684bfaa8be5d29e4dc81736d041c4b653a1d9bfca411aeffc9287e6bb8ec2b855ec46ea01f67989f319c7511d9d69d1b20aa7edb20db95cbf10068e1299780928e9e54fad193c07bfea7a880be6c6f19cf33cfb05fa3b22a519caf140dd754f075cc4e9a9ad0aec87ed1e2edfb5b66c5f2bf6ff1f01b1611a88cb2eb3c709415315ff613649435029f0eacbc466f43c6b1190d0cea5dd78226895d20ffa92e287ac6743391ce1e916bea74fb4e9d6116d45b444d3ec530d150dc70b1b2c6add23884b1c131fd4b3d4c8c2ca1a56f5e8a16c8e30fc35d69e501df906411daf7598d5814e90accfc9248d8c3588bbe733abac5c45b88cdc4cb6647fd4503ec573ff3c0f8eb9fd759c6c21cea13c49acd45c5e29b8f9889260ebcb6646bb7e58ecedd678883e63396f280004b54ae2ee23ca66429556b9f545c56689ab95315231d7e953bfaf316026b63729dbed3301c51c17d79aa56785d23f7ecb6655805e4788ff1146e5f6f9e3229e1fd17b930175b8855e626c0d9775862b94357b18ffbe5350a7c767733379b62051cc0bb63acd35e4751eba21ba6991a9540a2bc2aeb44e2f185e3e2716fade8b5f86264f0bd9860a43b14c438acbd59533a931df39982abdfc7e0a77022159fb6743205747f50bcd0d3a61a8fcdf800a0c2c9fa0b22bc73199eece856433aebe62271cfa71683945dca74cb2c56c8eb60cc6f88a75d34cbfce33bd086cdb9cfecd1bc90460481aaab5467242ed112cf6216b4d4ff2e31ec3fcbbb943cc6ebfc75b9e2ad59b1446f3b4b606b8ea4f450d34f151772ccfa6d7ac50a7fbc32e8f3c95c17a083120a3f156e0f479cbacdb12c542523e365b8f76b6cae60df3fea60175a935e90f7f2cde500da6dc60ad201a5824e7fcbce5ee5022b2cd3eb76f289c7a5df54028ef0d1a977a55bc39f8efb127a549fdaa7eaa47217fabca9b5256f1761878f7e21547e8a50b4d6abba9c16f8f00e34b35d4ade3eb0b077b81cba8e55b2a24b57becbd0fe0ae0f7c952030e5e64e09298ae1ffd6637563079965d8f41e8ed2195f47bd8ce19ed7a549c9938b9de767a1a3be5c9c05d42970408d89a653cea7734630bccc8a212812cf6576a32bcf93a089a7d5a0dced10968d51823cbb17413319c3163427d348a03e5fba438dcb901f8469ce196219b56792e7c532e31893631fc6b8b0ca616f1d719fa0555202ddc2224af00f516c0100fd19c586d3f8c4817e8bc12da01e2dae20b0b6fb5c8164f7b67f62ff6e77f5c28b9f3f6b5c06b2d3b74db359da8e205e310247010ecc31eb9656932cd6797f92bb0aabe33c3d72a35dee0173ee8093a4069507de238f176d12d18ea948a599d21140c0e33c070b13fd8b42f0a1a79ae66e16181153c1694c578529656c2be075c354b34b35503ac9c0da7398c4565f5868cb6dcefe3e46afd45afd211a61f244ca16763e471341d9eb81dc547e9bd30d7552cc62f8ffa9b58848fd6141ad99995dea9d65699a46d30fd409656b28582ed70808adefdcdd650207f54cccffad5e3eec12810951392da10d05ca20cda5f8221434f0e9a024a3fce1cb5b928df82356213d9c9126de8d1fc4ecc4d9a3de247f827eb3bef2caf47a9fcc251ae57eae162d86147401a5888851e1255bda0ea8b752edfc9c49e3fdb56faaee570f28fbdf94f8294ba68d0eae7768290724a741f92488942977f7fffad6c72ba5784f8ef083a4f709901c579a7ced0f3412b0f9b4b1713204b755a2bade08cac7230f992553324c27e8c2d0829ecc21bac0e8e0b26445340c9990c5ed3101f27422aa8fab646ccadee493434c873bc0909fb1e3179864eacfd10554838bdacacd3a9b68c3ec12ec7b8d07761aab0e667ce80af65ba80bd7aca5008620c1ab613971b6c2565575607351fe004d33b572af10f5241928d741121a12fcd55f9f52049bfec4dbd67c42c9dee1575ffc0aea7b6634f9dd6c175fd8e9d178c313f945ceccd937ec5da49d2c56dd0d8f3c095785affbaab9fbda3eb20c3e73b5f23a456644b28b0888d9405b7adb11506c5770ed55f5054ea1e87e43d012b80d9046c3dec07ef6f988595a8338f4bebe575a1a9261a33057c4cf8aa5cb3b1f1a317fd8ccd28d53f95926e697fb187959246dde4ee968b7250546214e4e51f12bd2ca15e3ab0cfa38e932c770a6fc0851224677b00a5494b5d51557c7b1109dbabe148bd332e9e9ec4fe66cf4be40c11f8293cd6cca611ea0effbfe7e6136e960560f8f0263a76b6db0c55013f51d6dabd60b9923673cf95cbd2d65d071514f469cc45ba925b3183367e0d64ba3bb6adb43bfa75f16a805a254b269888912bdc8feb2f22e5b4c013085c7feb890ae9dcf5114542e5eb6cbcc9b09dd52ba9ab06168c03974feefdf0feb43ea0ddd86f3c30a91bb1ae07bf6f2b8d2dad0af2a61b54bc27de0f18fecc5634cb0f59d2350eb4a852e11bb6e034f33554beecb2aa3174d26fe7833947532b3c8046243ff249bb5b3b92b1399292ab46f5a8a6756eb510031223b477547555b36fd55d6f5d469be6ba0cb4fe1ae8cc3ec6664321a8b3efe0d2cca1f9e51fd93e0a679d58e97bbe51646a46341831fa65924f6539a9ff74eb4290b44c5dd885ac8bf9f0ca9804314efb082a0731eafba832187eeed3ba5a2c316f22e05bdace484652aba9c6ca02b1a157a1bae1517ceb52ab1eecce1c1e15cb6cbf22d7b0ecd72a469c9b46b61dc5a27767e3f524a9d05804bffa8492176fbc50f1fcff7cc9943d5cda66d9e393ed7d81c547b749e5080105046784b0fccd44ef8eb16ccd965d96140beefbb2250b81b141deb26fa0a561471609d06fa8014c826e183b73348bc88302ae34587ee6bac5b808b6caf6f3a622c5bb0d89f1a46afc55ecdf3ed18dda58ff4a4895ecdbd16bc75be3c5fb4bfcc69902cb55d873338f708e1549fedd3e1bb20c5fb1a1795a2f317ff64faeec47257c3ae79c70eac67baedd034ce7e42674836a272bbe1bf78f6ff2e815bf3d31bd50965200b8738faf88edd131d8a4e348057abf1aba49f43eb6e12e27fbd1bcfaf97068d18c07f3a09dea8b5816a01a481b249904ee6f9ed2f2370ae52aab4faf9b6f19aecf7d22f899d45c128e50a2baf851706f4d0b8894033814909ce98cf2ce50208b82d8c34084d319aef85fe74506c89c817244b99f14f7360ae35921ea3d0edf27cdd7127ce4e9a3c81d322474f2f6e07e842cb356727e6bfd78ad59552a04995d53dc4ebd6136e608ac4a770c349c50663056f51243e6f9138026bff3b366e19f49b83627a8a0adda97a480eb8dbaea34e9143068366dee728ea6cef282acf1726fb76dc7d60d602728fe7e02ac3ae70619da9078e2c5cf2714c07cf30e19d39bd2f43aa8a057da5cef294420764d5572f031effe43ea8fc2a2f982f027cc421e327b3989faa34d4a1e100ea84762eff81a73363c488e851de57ef66061ed3a482b8e38374eee4b49ecadc7fa65fe9c9826446e9395d435c63b85db63074f92072cfa62e04a976fafba3bac74fa95428cfde9da22c1b18b54a6680bd0a7bdb103b7d5a976490146efff398d669f7e0a7e9d4070be02f3581b708b08086d0535383effab8da00da353531d712aa754bccad6c07c32b4f4237ee2242626c2ad1a17a6315a21a0d783b5e600632e166422d3c3f79aa7386c771061986c1d5099125cb0a0a603bcefeb89f791b64d9d79880c11e574ad80dc2eebd1320df53b4dc43e237b32748b629542f3d33399c6a7e66c49cfe2f88900c0cfab13535f474c19f7d578576077ae7792dc22e94752373189b9042bcf91d56ce39b75048de71a8e1e5a797409073855dc2b1ac6b5e265d8802eb7ad5877e753f04c41c894ecef530695d7c634ee1069d9dd87f8602b1fa36451637cc839334d43004f8fdf33b1c6aee67e5e0ed8b5f30f3ad6d1c1f63513f40c5276eec13d192bab0931d89ae079d2714c5fb6f82824004308f41571d6a6c548f06e4993a7a9e101173f79500064120fd2a60e1422d663981b9e4c3cbeab92793ff83e146f3230865d27bf8310df46191546b2406d70241d71c05bab92b9162694d6871fbc204fcb81ae7dc8187d2601c175308a51e50efcb2094a4a08b801054b0c370f7d5fc0723a786de567e34a04f55277d4cd266978f03dcf24acf2eba52cf11053a00d1aee548854ebc47e723642e81e267ef02ef531d56c319f4b4d270ec7974822be7b70423ef04efa0d80be1a454a97aacd6174c5459795980e800a3bab9f9e43ca7f93ea81a7f243eae886e0d0681d0ecc1c2ed7e3a799dc585e105542290ae8c62ba721591037d3309e83c5e59a1014948be835dc27ae7c0e3f8e03731f711f09a90191e823fd662ebd798cf2a0f35d74622ce58b45513c39008f2c762d74e88163d728ebf32029246b2402727ea3b0bed20ec77d99d8343b0c47f314dff49706d2983d2f7c962d4df9ac0fd1d916e9ff3b902baf6f865e3f5d82180adcfd3b52ab610256a1395af9fcd06a7079330f03dcd38a187c521aa0b7a81a5ffac4a89b1889112f793e26d51f05288cf21f24a72546ea16a00034865f8e5ebdfb1ce1dc51e9cf233e6be7cf14abb8ea36fe9d79bd320b978679f10dee3b6dbf8ee848d7aa3b715d19882a4515fee9455c37d4e93c49bdc98e22e6851da0924923841c0796ec8f3c5699b498677b82e2632b174b5847905bc6bd9e0b953afcc3ee9cd1a4518d05bbfebe7adec2a7a92aa7524521e37136de5c8ffc060f2e8cf4dc1da332ae2dd14ca4ed4f07f071257e26b595f630df7cc70f9e162dad975b5be465de3ec33b0483260799c786407c0a19d453124e409e9f973b959b53552cce9d7fcd9821db8715e8205772501dbf5d0b0c12dd3b74b633c9b8ddc2e77c7aa8bc66c59be3babbe20b4ad7e91b9e54a556c356e02ca0753dc31d59b391b65245c41a13e93a5f908ce6bf70b54e5cb1d63c475c31ae687539c8b9f51feb2a4d94d9f692ccc895b91d707b783076a869cdb485988fb5f0271da59090fafdcc0a1629e8b5ebfb39db5746346e7ccb6fe4c3bc4075c4a48342ea652e893bc42b4b69014199bcd99380d4e12fb99703adb40da6a2130bc19edda04a1d2078a68f2666edfc8f4262283d38497e4a60d7d430d309ec9e840d36fb615ff6fdf342a53a522c5d462101389123403b76a891a2ac6ff3d3ca96e2b350998f34a15a229a2d849299a38f522139513c9dbd5b757386ffbfdeafa37698ab2bba73e0a5065c9e3041a8d9551326dd6918924756af474f49b125061a78f593171587befa7e64962893d1e10af3e060b9be85da5cfa2de3223cb202087e3b453452c93c50dcd3eaf1a8798797d9e00695ca558ac4198cf613df1a9e16b37d93188f6f6414fac4f04899caeb128e477fb3ca6b08b02c7d5ad355984bc87d1059db50bfb299f7544e88149615fa1744c751d50853bff6d5c594f48d33167669acaa69dd8b55c9698698eb47f2ee85a251b75d974b256c42cabf2256180705e17a4dbc28559d420c2ca88ba4540455757ff7b371881cb26a0277e9761ea766a0d8eb35cf471755144cb38f53508436421e94a7324a39b6468df66e066f99ea6e84028d44f266c9c96a21e4a19f365ba6f559aaec1f466fbcca0dee46933f15cdde9cc38b332c66b0e7f1c3d656c920ba742963ca45a1ac8a10d9fb0d3c233adb5bde8875eada726256deab763a3fce6c3665d1e253c19a9c4da0ef94ad9c302ed27449ae5f7f2584e65f71a04dbfceafd642f4f31140b605b0fc382a1f7432e33f4a42d415809c885b8e5f72b1ac90606d56d61e5b0a96043d97e10f0ff4fab6b4ea962b9aec294eb415847913c12e1e7686f663eee9ac1b663f3aaa158e455d52d133a3087821a9f8997759998fde7bc499ebadc6f2edf210c55de4e1a98d8b58986df97ef3436a286fb5110baf094b50992e5d3dcdd9dade6540d302d609f8be9995a6cda628f79e09fa0c6b94fd97a8070e403e8de76433ce6cd2ec15c8c0b8a0a80f363fc743900fcbd2db2c494ab5bc0e739355ba987ace4b9455a4c8843c349fe0fc2dc2206f0b16377b150fd454506986e616adaf8d6884e26d87d6fbeca7e5eb71e85d392b11bd095a1acc1c267ac2ce2c56f5b3d76bd07801a59fc72c4fe060445696d27f11afe2b868ef25747b018ed5bde5b6ee3548e95d849312d0a9a0920606b0bb0cdc6829d66389dbc7b636150fde4bce4a5f68494f8f12410a194ccb522a8da2cd66235c76b02077a72c0998950b03653b9708278b4d69f21207626fd37377b52a1b7b84dd4b318c0717d608f762ed286ed97e01321b6a210c5a560cebe28fb182d767baa9aef43c0c986f1a5038bef460c598c58e3fd726f5f04b71716dec90caccc34137e4396f603f6faa70fb1fbce82bf24292e06b42640bd5c620c72b6e6a985181d5a1f083dcf14a525308bc9398bb64d876698727a715727db4c13bd2fcb6b0e2950c560f5e9ed7a3b2ca6785dfec3b590d28ff5c18ddaa0c1a1c609d1fee06a355acc39991ee19d2c4540577d095b10978c63fe119f087382ca51ca5fefc6fcd798d26f510afc14ff795e095c4fe5ffca0894a1b44cd6e827064cfd8ea9013764ca6818d7244f9cb2e5d156c47d494f8ca96572da6abe39b48220544f47fa34d0072574e0a74586530f1561af1e1c57ce5bc87d98110a84a85f96eb4fca30bd320111a51e77a70833a75720b300006dc4e5ddfe5cbe59da3ae71b5f35beb83bede7d23446ec4e9c1767d7606e200927b7977ad80f04e416fc80fdcb165f1942de2cdcced2b62a24c30b938d2a19b961bfd7d69f673eba1dc201487f3a463765b84dcf93f67e541f9767540c7ad9808d70b0890350b12e4881b8dff2faa2f5481b4d0ebf0c88f996a0fabc8f49452101864f38fd2fff6fc087e9cf2379e5bcee402f37175edb4c56ce7d014bcedaa19efe730b3862b3201d5f0d8195530325222e3550027dd176624b9495b6baaf163f4a4f2c93184fc40916420190982a09b4db82512f002427de725b4860e6f6040426bfe9ec7cbf1d2d5fb9ef97722e2efce94290c2532d1bcdc72d0b2848061e9360f5c77e605b1e402ab20d91de3abbd299d31023abb917922af08afa69d42847422ec674b0a9b3d2ed22ffc9d07f3e1edf6d17cdca4c19ebbe5356b1755c217937609e70c5d4fef29302e069f239e8cce2ceccd473491e7fc40cb0c3c78d624e8ad8a0e28f45e9352c1baad3103b5ce24e925cf9c554811cf14f222a4cd6cbf212d5273588ac43c35deded7095fe172d06b0230912c2f5874913361d69360bb162c774fa6ef6c97bd2d5bb99f46a7b9fd54dbabeac41f115250775236fb79a6a690d849ae094a945cb0efd61a3a4c769892265775d65ed9d31e1d5c74a6b1e535caa241d06dc3af54704c456df27252b512762a6f228fc1d201aea2d2faae255ee970728cb75ab70d85b70bcb52069a4c5d6fe96af5c5b77e6ba419c911bcb537a7b04f3e5457518d032c8ea39544808985792dd4784d9b09fc9a9933a775f2650de96577ce8b8516dd6c9ac76a1ce9fd4ffbfb27d06f9c24ad482a70d917b36b6f9dbb1e1296cf33647e43468d0d65e13540d1d26f4e34beba35c7328071561b355be373db4aaa8d2d548026f768dfd2636cf8803f22caf92dae7329cc9c284f39c42e49f31a6eb8b731a01f3fe3ce390a9e8f4cc1f015e8913a4b3cb78de079162bf4f56daf298b2732d693240c18a5c27be403b91d48a37199a849e1c8af1055f7387563b7a558ad72f70d42def7418d75bfc7d5f6b5746390d13b3846660cd83d1680b363ff7ccf97169128503bfd17b2e9c9772a64dc4496a6b72c027a76bd703e1187df83e07dbc9a5942ac4d8a07ddc1048d50d48eee5eb283a6fc99a891adab542a87b346a94ca4cc016ca5bd61506550ac933634a9d245eacad37a346cbb25f1757d17d0082733802dc0fc05e3d4587eb74c1178262687ca9b43b6104a658241cabfc4d6543ab545184d9551c6e028ba486c5abc26383df03be3aa9773b3980d5cca11a26a6dbd8a302ea80e5028fbfcdc6823425836104d1b413c35433206cd87ace14e23b6888b958ee06a99975c7963aad0a1411edd3a35d8aecba8e071a26fe53681484b786958114b448209c8dadba1bbfe376f054a842982415ce9e02d29645230498891e1c9a4cfd61b2f38cdb05ff317a2feb80e20aeb294142ee64472cd97300d299ce1abf6a8ac9e271af0abfc865a003608fef87ca8f86adba0341e6e4ea949e6db2aa4c7c3bd704a41319f12a48593b6097b8daa1a491790d0ab524ee97658b1f6ee2af32e409eee34488f35de47fffb429fbe636e902314de62d59da949be526c0f61e04cf40397ccfa351fe1fea51f0b13bcfacc89471e8ccc23631d7647a4a8a6be45f277e0b3353902f79590648565c59f196c92aadb19d4ddbef08e4fb8acd755490b80d47ea3656e2766d8a074c04ecd7fa3d298ca1562b142666f00f86b960550ce519fe6c91b6603eff70b1c32f74485283c194a46bdcc8e700417410ca49f223e8a8a3ca4a33eb9d94ebb08223d142e511a9f5350feaa8c2c8512dc4dda93aedb042170bd14572fe8f42a3b0d9f14d5125546b741c566cd91cbdcfd09eabecab628e7120ed724ab45b9d8924d1b9a4a76d68b143c6e8fd1736acba368646f5a9ba72567655cc5f9ed60520cf3c8667f6eda9973e9dd00c2c0213258702da7eea18b7acbe5238f0bb9b977b7d190be1c45b769484eee4ebf17a0340b8698c980475f2457f3d82b70e71de565e8aba293d41ac14c84ecd8decf312a2f29d0a492bbbbe1147df1ec1c5cdbf1a68b9abaaa8a6c97eb410b8a17d36a06a4e35f5372956cc53b1d6dc911eb3fb9d57286973e6b63b14b5480388bd714208fb1d7d1766cf5029cb99e20552af5c3935193e8eb0de6d20b5e6055a835cbf87469666914ed708cfcffa65dda6674dbb7e2975e8118667381656c6dbb8827aaea11af3df513f20ef5f812b50bad84a2ee56407c8ca5483b5c0433e6c57aa69c8f50b1c5c54b31d5f80399d2d733b20dd12c5d0cc5fa11a601f8cf900b0985d8ac573b1ef5fa997fd30b078486c588a197d5814b04aa2180a99aee85138ed8d9854cba4e0700772839361a72e26713d96455cbf9583a418614d8c887fdf25d6602c2a0d39df0cb70c57e2072055c300aa68e9b1d0ed63f3a0bdab04a56e2af2642683e2d69ecf3bf6d907a429f98b064432f87a0e95fa38da112b7838d398e55686470de05fe8deefe6b6522d265b5c2d9c55a7bdbd0e76a73abb08da9b0a961713164f369c29b15d4c00a3c1ddb5d937bcb8c9c79e98c17502e7528e60fedc345b98041bab5acc4d93630bb28a9e4fc9ea78cf010042e4dbbfdfa8f07e9341bc63ecfe84df8365b585b58b1978b2c09a059d56de37aec7adf52c95c2d5385e348f985a7351b353258b8f2f53cf6ea384e152f50788ad81d05b61632a192932ee2878455abd20f7fbf09dfa00ea84c5593b373520474cad7c3e19f35b2a02ccafe7ebe2f0b825596c74956198890a533fc9c5aeb3c332beda3dacd38c306775490aae272970896a752a1fabf2c0af263413b3e35bcc59863eb147b86b53eda3368b5b990bf999e0cbe772a9727cea8f70ff2de3b0609d8734f838d5235030945170147b7cb02a85b7c626cd9960fc3be78b28c3301ca16f558366a5bf4044af70007d02964b9705fee2a00aab2a32157672e3aec099070e69f0756289b18e5a1470dece0b6b79d3b7f832ff65ef377a65565213f12b988e39495d4941a3ee2f61a647969ffcadcd06a55b000e591e619f3d5b43e206feb5e6ec44ce3fde4eefe621a01e94b08e6ba361cc44387bc8cd6cfba28f4c150388f2629f8fe9e879e078a6b4f20562aec88948344d92b232f43e8fba4e268e175ab0b677842a556f7dc254983bd7a65377243fd1ec0f9cc5cf5cfb4479e8073a3e1fc9f8592981a18d16083af6d82448e522ee3dc41bdeaa21be8ce8fb30309a259f04a9788ddfa85f997f63dcafcd2db944598725564d59999c6868deab66fcc822d6a50f4b5ebcf9ca729e4741054d3766634392390d5ba393b48260ee1373f6af12c5a6ce85f7160bef74eea62d739726df1ec7c2fc5daae515a8b7af424cdd6b336d59d01c223d90fd4e45d67d6622adad4aa30e4781b1c8626e29d400ec1a73c3da858c37fea80744f099a25bf9f4b7c219de94546083ffc02e22a72d70f73a4f21d1b5908b881dc85d5ec2c0b4d2421aaeb17e1943ee53bd597548834c0af724288e487bc81de6ddac5b14cb1223650162e5340e723d2da4bdf535611add3a241e2646cf613e13720d8d050f793e20856e593a25aa040fd5eb853e4a21e869cb46c6f0a4ac782493461cc0e5190375e01b15062415e495cec7377ca197a4ebf3a27497c2bd57a88ce59cc4f4f1f1fdbe0b51a36a708fe66b1be6c4a170f159f01c00255a3c0312254519fba33b8ce7c0b3eec1841a9e6189e09849f397c80f754b0cf330ebab93cf3673c9ecd32759e9545a3d568fb9a77775172481d11be7843b4fffadd2e85f8aca446991778f21fcf2d129ce8273f773d956ef38fb09890928f83d6682e4117620a9172d25a0eb65cf9fb67cdea44fcf6fb00f43b87cf903f2f0559293544fe030249e3aa5d9797f5bac2032348265995b63f74b232a2899e536e54e64a740877821ff26a36b85b8555019bd83c2ec71676e5212c43af326cb7c57a508dc1a2de4404fcb554d0c4ac0f44b761e0c36712484d45788940dc5d5d976f233d6c18f1cedaf653cd1d9e67738b7c093bc23024938f2f7553e4cc147c863577952ec3ea8515c9f894a82ca196d395557fad1c55e0f0cd172da84622909a675c50d611c7c745040e3fb9ce4cc6b0c90d8da939af84ea42e2f66a70073ccc43737a2961c382da0eae36c0039e47e93e1f75f3635839545c8bbf655a617130ec0a743752467a30a5d3dd246dbcfe506d8297b1c9d9d1563963b0c73e7a8323f9f186793e312ac1c00252db85420012f4925c6e6e751cc880be9757b9df29ddcbf00dcce12ff8ab04f6d2a2040875418630a5b32f54a488734a474ec9f205d3b1f1cdd119c2f2dabbcd30dc032419513b8438a235404340df9e79707c2a23848b185c3e5a22aec9d0a4e0e9fbb7c54be7a2175468d7a2598ce1c4dd5598331b160687bad4210aeea2916d2ee5c1f85e63b020404aa8b98fe6c5fa1ce24b10d46b98502aefe358c16557b992c6fbd89a5bd79ab858be1f7d2b5a3c803b62189590866c4aa1c92ebacdf6c458a3f12248b47fe2b098784b2089723109f1e278e86ab33310a749b0d2dde324705526d6b3b45aca30252b08992bd2bfc44bc5341f0ca7e81f06255bb8ebbff8128cbf735a84421a79e35dc7dc4a7059993f7af96f5a87292fe33c3d7e8744a744d83e3e163698b4b5ebbf0022afdce9a4dba6bd2ecfb98d223753bd1a7ff017c9d4659dbfc9d13f5decaad9f7c8fb4c92e255e7d16fa9cda0483e4c99fafc37090e8a84f8b8f8dd794327acf4d08e59b6a89acad530b076f33be53c0c5e77e94b33357ac91290b22ac9227b7a583e481956907c9f235e36aed0f52c6e384896a6a4d4d594642181107f14fe519413c999c42b521b32237696dd3a9bd4914153d3db0869fc28b4bd28dee51262ed94abfc033e1a02bb8c8f1f59bdeaaabc3c86795afc90d5b7a182564d33a8b0e6431ece19b6396a7f766235794e029c987b3941809cd7f027f0bb9e9e07b9035a852152b1a235ea0808d0caf81aa7c0ea5fd1bd3db1a2322179b3532884a6741fef0c81643bac799c68b53883545033d76e892decf5836f1007a92a8576e52dd7d32f00487190e12820f769530cb4c5445b17d3cb03984f4c2802b698df49e094088314c794ffb9c701623ec9dc861191ad84e3799f044b20a8d35648d1f5b0388e3e16730d68036c47953781c4b7221ce047ff2580830f8843e179c0006b09beb373096a8e79da23497ec1b313bc0106428134b4e6bc50ba1ad7df068b94c8702a322e23c9b531ee838afb099a4015d4bdcb5dd9946b08cb130969cfc860755e0214c113c21b3fd5d829899329deab83c62bfb8414da595b3d4ab364fb8bcda3589e677806a8e00b79ca71cb30932d0ffaf0376e455d17a2be176ded089c480b1d028d8994e00f44eff3d9b520c8b4f2533a7869e6698c40d99e2f88551d397c023dc591bcaf77de9e2d13f8e3782343e816dd45e568a58a31b70c8c0cb71b56a75139513456bd31aef5365486ed606a762fe4358c73b725a6ec6aab135996eeacc80699c819afa4688e623fd6700e473e37fa750ab911125579b2f3046535318c83023c4c306d2d5313c051c47f7d8bbfa9049c9404f586fa0799aa2d3d9ff141267a2d14245e187e15e3ccabf7b5d79e7ad0a1319b902a151035cfad149603b5bfc2a4a5dba9bc15b1aaf712cb120f9cae9b4e16f57ae97d11ea83fece7a9e383d7882e9a0877c573319fb05893043d430a991b1583fa4b318846ee7f181be82d7df7edcb31290fec8e9016a1b897433ef68edf24c00fb1055c4ce977ba226e83cd1fa43db3950c16af8bcee5f3a74a7e5234d0c87fcd56e1470278fcd201e1b0c5c221ba2b5a97703fcf924d40c2606023f434776eded1a212b873d995ae9ed089e7dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5a5070a1f898b3eb7ca64bfa9752f7cf"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const {isSuccessful} = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4=";
    const imgSrcEyeOpened =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiICBmaWxsPSIjRkZGRkZGIi8+PC9zdmc+";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const {isSuccessful} = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
