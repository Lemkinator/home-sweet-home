<!DOCTYPE html>
<html class="staticrypt-html" lang="de">
<head>
    <meta charset="utf-8"/>
    <title>Home Sweet Home</title> <!-- custom: Protected Page-->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        * {
            font-family: "Kumbh Sans", sans-serif;
            color: white;
            transition-property: all;
            transition-duration: 0.6s;
            transition-timing-function: ease;
        }

        body {
            background-color: #1f1c1b;
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #2a2522;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #443c39;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #c98369;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffbda5;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
            accent-color: #c97f69;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid rgb(128, 128, 128);
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Home Sweet Home</p> <!-- custom: Protected Page-->
                <p></p>
            </div>

            <hr class="staticrypt-hr"/>

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <label for="staticrypt-password"></label>
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Passwort"
                            autofocus
                    />
                    <!-- custom: Password-->
                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Passwort anzeigen"
                            title="Passwort anzeigen"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4="
                    />
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember"/>
                    Nicht erneut fragen
                </label> <!-- custom: Remember me-->

                <input type="submit" class="staticrypt-decrypt-button" value="Weiter"/>
                <!-- custom: DECRYPT-->
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Falsches Passwort!",//custom: "Bad password!",
        templateToggleAltShow = "Passwort anzeigen", //custom: "template_toggle_show",
        templateToggleAltHide = "Passwort ausblenden", //custom: "template_toggle_hide",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ee795c8058843a3082b6477343a4aff0a7cd74260396d305596885acb13f36ac72d24ddc80f218031444da1395df51e708090e2f4daf15eeb751f152f3a6a2dc0faa737c3da107eeb69a333791d96834133e197b693e4d212b9abfbc127d7ac9ce61dc9993b8081d98de994dac750d264b27d614648177c4e21dd6eba90589ed0353a38b1631c25a9ab09da53f0852657f5f9bd30506c4e13e5ec1507e5b3997393e6ba8b3c64ad87622f99566979f173dfa9871d37e1ae6a2925f9fa12e0382e0188e3b3f3c5daabca967f3dd579cba46a34ed281232aa010c467b34fadbb185dc92153f320ffd4ac91fa631be288148ca5f41056cb2e0c4e30018440855e5f1a908768929546bfadecd55fe59f4efc79746030faf54f60cf3332d293b4052fb1744ed1b942aa14604449e254383789e8a27e12c4b4172040370433736c6085c3c742ec56805862acd19bf05fbc4dddb6544b2c417e6032999fadb4214c288fc9b5ebfa79f98b2de4d9d27f2a198466f79b43276bd4a3e9075278e41d7842976ea51fca966fc3ee568743d0627a68cb3764b5a85ef26b388b5e03b6b9748dacdf02c92b2914ed1c6fd6e9a42c5df2d21b6e4e64aad16ed6e19571cbf1509a01c5d6e327d68d3128d641125a94d98391964370fe814907645a142dcba8fd2d38b5b574b88699e8ab4f391f0596289ff935b9a6bafd8ee88cf24d55f1bfeba6ac1abd5075f46809f4f39cfe2cf6aa9b64be0dbe32ed6237d04b11d032aa172c197cca51634c0f076200679f50d5e5788770d1b28f83de8435e1e9ace706dc72abff46b60692754fd2e98cb2586b196a70eafefd0d03a5cb666a1a695878f4885998642acc00620f668fa29e0ecd4d3f8bde31c6992ca3174eedee7b2706f7b668eccd3c7ba0a54235204d3ef63fa0ba5d15196b173aab31d789aabec3021feee65a38e637af744e9dd531a59495d44a5061a8543c01a4badc47b3e94b6894a4d61b675c34d12ea260b8c5baeab4aa87a73d3d591f892e3c091aac09ca4ec5715ca6ccc10a2d12a2a764542fdf3c42914082eb9e15eb17c7a70cbcc6706c7bc7bad90de6217226e1f157b6791211e2a1c2d32231626bfcc50609b41261a27237bd1170323dfbf2ace9046d77b6483bc1fb47dc67d0dfa2eaefaa3888978befbbd53418600a728ce3fbb2ed5ad196433213eaf9e834ef34c1ea1bef39c3a7feee9cc53c4ef2223773201135a2a440d6731b91ad9a3b748141312a602a73ef280edfbf44a227956498122e48ac3e3d9efdb6894a5dd6c36cd275d64f53e2547662e042632d6aa2f7dfa69d2e45d2494bcec195e9fa373290e4331057363fc9de464bf3a90160fad49254f61f322e109ec5a59ecfda06bfbfc8175c4e4d5a1f73c78d8be83609909789e4f8c0c60ad5ddd5c37604d89ebd90700f575be7b33c094968eeffc346ca1dde8df1e5ac5507b5eb6dc3aaef57eb4461cfc519c958e5154b44cfae7b65769c3ad43310e3c7f9308720b165dc47c008ca95796b126881add4df65bd2d2d043f73b0b9aca946d4e5bb54b6fbc9755d50bdb41e1911de8e0d638bab3bb661b3a1404e833546b6bf3a2257505d445887d3857911875dbeb3905759297d9204a511260f747cbb67c7616b16e2a237ca7a4102d4c5e58aeb5a17f26ad7e2d697bf77d2f5356b52ab844e260ea44c46f71612c64c82a1cba06315ace8213222c7128216957dbbd7241988545da6f60c42433ccf6a0f91fa3ef905b9ff35cf105db5072d7b6f7b7fa447ff6add87fd8b0a43bd55c9827cfee130001ca8215ae5af0ef2bfb9549dd4b38746a0cc1f39cd5e5ff55bd05cd446254253cf5b25fdac3d9190bf0b103c9605003855f4c77de889d2deb80607ffd3d97c269a9bb667f8e0edb5b782d82e7d22ff5965cb5420e177e97b1af6818c1e901f9ddca2586de421bd0b4ae9ee71b656e9e0c9e518de32e1f101306f198510866ff231e07181412c6de079b407ee6f3d4566c45bec75afa815d7c9056a4a03e4cffaef3f6d5fa0c5d098123c63a91f400b59cedbb2a2dc61fdbc91643deca32511709d23acbb4f49641c8bd74ea414c4430e80c5e8f9bf2b7bc5eef3243d26b7559ae4778aaa50e3bd9c1a28bdd239133ea0069eefd75a23804e670be02c81e755d7779fa2ca18f769729f2b665ff464352a665bbf27d2f769c992ba024257f3c0863334150cf723753b4776a46b58b2e7e0196cf3befa4fcbc817e01eec427f23086728eb0da8121aaee462f9e74652192d76310db1500f67867997723d628f6fc76bc1c33b1f24b3527a391d1a099b0a3b30191f13a3aa0a847e30ba618ec59a6b52b930a0b613399dccf04e9601d5c51ec9097fb3e873f32d0a2e5e30ab9f7c3436ee9d02ebf09bb3f002abb54af07033e05d7740484d231900b7a6622eedd5b4dc5dc8a91e8b11ca76c88408ddf1b27e4b6039365c444dcf5e8094a06924465da5fed92d2631d5ea12a729e1f6defaf659d110cc0222ce281d35020761fdbfd0555ad5d4774edf10417962f2cad89fda791bdce143462a448ff7ed6b9b598ba3d2815a6c1f1945f9252f0297f13b56209f471542e9f27b254ef1e7055616bdf0dd09d4268d55b736b3562c92954d5bc3bd4271d300ff34f8b1f9c585cf81fe1f942b27a39dcd00073d453f02f27673cbd22552ffd34b9ee7ecd3f263022b29affce9036b219e51c2f1b91e1733bf77b1d692b8e9188ade472cb42223e59cfbad34567f2899377e1af959baf681a824528af04bcc7b6885a6fa6965f8e8c29bf13c2a055d47cca9f4591aa9ba73b479f3a9538d28afa2ee403dc82d594aedd7eda6ad419f8d45bbdcea23a8c6d44c0e1156a727267574da3d4ad7ef4a1a0c9866bbb049164a0306ac73850c121cf94d7e32ddb8f29d36045dd465b3ff6fd41a5ddbc93f21127d0f75455532ccebf0723cd4f230888e4229ef2caa465879832edab013ebd13e5e580630b404b9eb2b79f130035914fd05f84e455922f64990543cb8467c58c348381a11d45c705019177e6ad8605bd1051f300a96087d018fc5a55302746dad42cd9b6e0460babb3971dc49479c2f413ba179f080894c58617c45394806ec86a913ff02431b509dc86fd56022d4bdadde8da77d6bc5c76c5f54fd9aa0f6f4634b66dff9777a46b05c157ca9560b6694ef5062c3719b2cfaeb4ae36d13156d5bdfc438982530fef1ea6567dd78b96b038682d61e81edece5d9bd71bfc8665a78995ef1a926d916ff35ef0a3583b8e493108574eaf5c93108c9bd70763790ee4a8beae09026db7f4eb20c9e96fe55ee07579ba840b94798424d9d5a4b608f6ccf61ea700f19d8d05a3560dea0359ac998b3b2e57dfa18daec41345d75d007ec40c257ef24b00150573095a7b049df34e3ec9eecfb18ec0aa16c30e09df23de2ceaeab013219f4aea6f8bbeb8b09d688f14429ede45af418c9224409041811a39d5e955269e27226ba48df002bef7fa5530783729bdc7fd0fe9651974e0e131ab6a1079d1b7847ace76826f0420e0e87323f73d4e565e146744c848cc3096229b057c666668084b459a25412680cf637efb9d0b2d4a25b9242fd0a2d809b48c513a7e7a592ccbe79e9f3b1a1cd72ee9272c11d22846ed48c0414ef9f24b0e7598ee2661e5590456edc5019396751c6bbcd1cf2f8a1cbdb079ac719346a18ef12825abaae2bfc1352c67b0903a1e02ebdee313f54e26eeb35b18c3fadf47b366fe228b6b931d5d07f57ee24fa7280db541760cc7c4ba04140cf6c5fd5011664b2b2c1577759b65742cd381ab66ca7733760c2aad679afc1d344c5e0762564bc645eb44b563d66b9fedbdb9a83d4d3c1b9f9e3b75f7cb68b6c276f701e7096ccc1022f1c47bdc4ad4d2ce5c42ab65f08b55020010ca7a4f0f0de8454dfe48c106d367f206af5253a09c2b64406ac98d6f919a9c23643124036bc0d4c52e38e6643b2e089e3d7bd61f73eec96bf9fa5bd462ba39ce470527018ec75f065b8acc7c6576436ac4444f2dfe6d97d8cfeb6f94101638a4f6bcaced8472295fc560b2714578c49f1809af3033add7f4bdc059a36baaf8838e9bf425aa1baacb1434b716f836435283be0336389116681a7cef8d99f606ff5899b114a1b03d06842802d8050aab68a375ef45984e645533d2b774fa1ed8afa03ccfce9e7dd5def959f910dffcb0dd792520af4dbc0ce1937667117177886027baf45bc9b88747402daa428f0e0dfabd5f5d56dfe86e8ab2e2e80b81c2599c9793813165a3491f0b4c93528ea854e76d98f7f6f5a2a43fe7c931e312d6cfdea7565de771edd646f2314d834c51e9b56a6e6b3cb09714a320cd833bbd7c2adc1f4020156efebad8783a73abcbfc623982bf4f0d5bf748f184397bb916f9ba53246b4fcaf83ce52dbe3efcbb466783a623fd646c8b66ac73024b3a8c2be176fb25d2529c5e6ebcd94949cf0e84d4267600f859bae4f80827f01e0f88cba712d6b7dadc30bd99d202004ebae326f045498e52ad0d7842f7a4346f5f4c86eb91fc15eb3596f467219e8f9ee3a5256fea7e538b3d6144c27d05bb1aa646698d91f77ba02f552eaae581c43ec5acae855a2d1178a769437f25ebf0502025e471ff38d2371cf87ab34f6b175f973cdd787fb3b22d7154df377a1c33c6ef4f5f9871d9ad92832c4908750a9d576c2e47a72db3a1079ea4c1cd8dcfd8f6062b12fcb7a9e552c3564e761e360fc6c3f55689cbb0f1713b668d754b27be163ccff5ac457e4a20ceb99cf66e5fc280cf08369d85ee08925e5e937280f72bda61f9738bbec14e655b50c13021ea72611f0119a3b6f8b39b71ddcde30c963d063cd32090552f15b85f3ce8a05f73474ab79543d4feca1b04d52010f310d1efc92e2daa765cdc92bbb774c5a8b82c32075c75440186d5a3df0fec21f237b13ecffe06764161a0212a336933a6fd9ed1bfcaf12da7957136424c054da3ea89b8512e5d95c9b5d0717abccbbca5266209408e8ff7445afd2219290beeefde5174bf2e9880a8795cfc344e6612c0d9309edaa416a9d2ba0d9bf2194c422541111feebeea19178f0f931d4ce74de99a0a7d7653bfceaaa926e493e944ecf6575e85d05269431bf7ccac0832e3b2aba7b825f6504197e3dcee26f34269d06cd58ec33f896f5cced2770eff2603dea9b20ab8d9ac7063da44e381fe4e75b4ed996b313ceb5778731eacaf61928a8a91cfc72bbb11e1d5d1b8ca7e814f80a45e097114b59984e0ea12fe5023f139b1ad314ac74ae13f9e13f20dc68c67d816402313c05efad153fd795a8038b68e8ca7faedf6085e2422458136d987d2cdb78ea204f8ec0728f10150f36245c14f9319a91f74a0b77483b8858c50e931ab72546778b2f0e3c40589e9063a07a04491d03a603b79e82cf62cf27577b3c10536a3b7207a1e2c40834d15e3b2f21caab25a3f6e3474d8a1fec8de81e9494d4d782e457ad070282b228cfad0a1388623e6e26667af4929e3de94c905909365bc61179ba9c080a496789af83645056efba0e5cc27bfd714f933cbf86d0b33fbdbb7c6f0d4d4bb8445fc3057e98456f686df7a607cfdd73abd5d011844b924abd41671ea632b72b225ddbeddf83542975b866eff2a025f9441181ea81a0d278f9fbc2af43d598bf81af9142ec850a0757c5b60a6e9188a746563b9c1f632ce8c196111b43fde26680b85101db60a03632e2b8f586ad38fdc2787b05f401c0f825b7121c0714ea055d10bedc747e5752950324700c841be7e70d3c4555ee1738cd432daae4c07d54baf3cbd327601fc8ec7f3c4a5d4722b1ee0b92e771bfae888362b06e6fc78b941709207b3aea419533b8f3d262b6cdbb89993b5e630d8b54e742087aa5f053704fc16aa97859348e8dac9b80ef01f0726264c1661f39781487d71db6e770fc7a98eebc4ecf219d64f0aab63d7952cea9bfa960de0c8eb8188cb41e26ffbcba804c600ed85611b692d9980e1154e24c00f6506e07ba75a0816ac7987f1f770e53500b5b9261ad48ab859cea7d37a85a27e99cd361a70cc5cdd1992a51ce73490508b1cfe562dc6dd56eb6dd53198c491a2b84e6713d7dc9a48c333d2afc99690d6d98c0a506a88c6bb4ced1c0f9f834edae189fe3d2e78141027667a63e212492b5bf9e106975004feca22360e16d6d7da618bb13805901272964d0a3510e3d2aa8147dbd5f060a773d8cf78b970d03ee07d7cc6965701ff20cca9041f6d002ef138acd2c7958fd0b9f21d526ead8538c8f5c5768cbf40a41b669fb9741569d60a80edb6e50f1efad71267d6e0a8dae250f9dcb0387302ad835ca901198b826dbbe0f40492bf7ad9594e11a82b95d2f034ef7b435ea0811e1b9462fdea0e5c9e5e87e005aa6275b495535e11a0e7998159f3100e5338e9323c2634d674e77e2a9bb67f9e711c22ade31fbf26c35adde02e2ba3bf52288bebba494b858f5a8e1503459d4d66c9d9199913bf151b436c958fd7f6c71ec0a62be389c80d48cbcaf5d42cefbf02f7615064969d105e320f5d00f2ec5e312c702def6d80949922c03b8e0217bcc660bb0188bd117f0a5b6da1ca8692d36a7b28852930edafc9b7c57a4e3262119ca9d7b9167545dbe35a09d83ba9b612f6a07c771b158bd80ad64c307444de7c1b38367b76db18170ea8fc79dabba54f4398d8c96d2a3cabf469aa8e4d68a0b9ea6ae4902a9cec93813de07808065ead760cd4a71527f927c9d1098ac60a6fc1a02de8cb90633c544f28f5261ddaea1f6d4f509588c0d33cdc476cae2e68629b86c6f64bc0318cc4dae0bb0e831891b84a5887a1e453acf1125247635eb2340b4408f3aa2414d832e62466003f0963fa1a82466abb5909c714632625aa4245c14d28dbb8c9dad19546ce182815105c1d5a81e247cb1b7a038f5810c82bca5834a02b0c56281fa619399f8e61771e49bbe9aef74a191a9fa5918fcea88efeb09ac235098da03d52176027a311661f1c4591e8584bebf03a46c2f5d2f77caf3f0701a90209d6e70d079647382eda91585f194b43a3a5209cb4d7a406998e8082d421e0072cd2c1baa7215eef650feef790a9db42d685b7e2558cbe436713968681868ac2eb8c350a080312367cae7e19d02897074181d5aeb8ea25316ea588b45a9dd817cdc8f3aba90add38854e63e14741a506d55a04b746d8fb7bc2b3485219f435c357f217b0435b76f683f704b5cb54def1fb3fb7bfb566d2621482431461bfd98cb3722af07e4f82b67933adbc39996fa75fcada4aed49e500b77868927470a89ab56656b2ce0d453191b43d29f8a46d5b425415dfe60a9e77f7c6f431b06ce5bbb69bf2f06b63a9c47a23c5c870583c654f8c364cc9fba5f6599ee99cf7ee5c858e604703c4033315d6dc3190eb761d1b66aec4c3b32340ab53c8e8b3735f01dc56a61b92be723c7d401e6dfca87eef16bbe3a42f790c74a219c2aee5eb8255d32a6c689d9c37b9ebf255b1b92495ad991880b0f7a0fa37e9b61da3d42067e06c94e8f5d76cde0c52b7e7ec5612284b0a32aaaf88f18c9b661214f5464330ab46f3dd78579e1cb1150cc3f16674ffa24bcef521c07c217065828787a8f394ee536d9f89aebe9dcccccfe4e6200510d475c075d5ae13c36610380c8b6408c75dab2eeba469c85df51fdd891557cce7bff2eb47a8d6179ad429799c4a7fc4d4fde0d1343ef91b9946ebcc138ec2f3265da48a6ac0ca898ae3c5f37565498e7f36b365ad662c02f5b1b93ba4019fcd724dbdbda3ae2ad80b3e2691ce996e04f004300a691ebf6c91fb43251bd64d1d6afd1321dd59274486a5c85fafc6fdc30a606908efec0306b92bd889d00c652182df92216f41b406446819554dc3d0b1b1dfcc611dba422c22071c2ad02156af1cdd9f7834c453e9b5771bfc001acbc1b7a75363abd2470ea5ff920cfeda8b5d39afb41f4d3a0e02d252585f07edb3a2588e43d442e673d473fa74f482d154c995298ae7389b25eb99fa543cd329e442d531d11b7658e4989d92b44bd7c028941ac1b5f3272fc38eefb1f6c1a3526be7ef22f7a7827270387d5122b9eb335418ef208b70e61cd0dd87850928b38aa83a01af5a60e0bdcbd23c0792a3c4c01fa5974dae5a01fa1a2ce041d3cc8ad6e5dfdfe1be58d243ba4f0e6b28430576e06712f8cfe9fea28574b44a2242baa1d014b995a3dc1021b98bcd2adcf8295f8a4c3742d6e57f51880aca7993695228c7cb09abf0b381c035ed90207ae256fc1e79b3e17d1b6d166ecba17024132011e5f8c8b9d0b1af112612cc5d052b3b3f24af745168c1aa89fddaffff734703941b550abd77b5db7159c36083b7c88c13056e2f6c7070ad6a754750a753d5b05bd32e85c5a1aa5088f0ed9ac601c2cc0f1be3f21250751db77433a36d1051cd786d2e9151efc9326fa02599ffd80ac9c3363510e93e3706cadaeb1f6c12835eaac413437886e6f887d5a50ee1892314ff95d1a4360906b831dad0050fda81952ba21e390508edbb8727cb78f9ecc4cb89d74edbc551aeeb9dfd22dee58e92bdc6450e0255d72b3b637595e0d674419c019c845bf0cf85589183bce6556e893feff7be4a680e01b52509572ca0409c7babb5f3cafac884019fcd31437f28e82769003e6c9135ebb511910e051f4c121e281659f277437b81dfd427bb94b5fe2d6fafe0b970fa5d0a4cea014f9f9c3d3916a6fdaf26a1bc453014c1071275edf6208743fa24a095174fbbd4e5e66a892a1d5ce440feb3f057dc0376b73d48538b8780d622a44711b924f1f45b41c0dc936acfebc9de68d056edd194807773b16ea6fbfdba362cd14afa418c2a66b941ce1bab1a2750fae7a5ca32ba89b1764cd8c677616677c752c795fadefa3bd577c17881b93f6f279edd1bc204850b8c09b49b4bb532c68ac653f83b4b64a307192f17de44f14965449bcb8db53709a6f9d62475b1ef18ba2d449c1bf4bae103177291e44e5475dcc4599b0a0cf247b1cdafc317c2787a3af830146c42f4f5865a31d02b8339d4ad37d59439f1535558d7f8cc507a78ddd45284c6b97262ffd9b3770bb4bd0737e0bdf03182309d2ef7b7766baa382de070f33af1042bc08f7ecbd2739fcd28c9f75674e2048e6f7d1957d6c96708bb7c6b6f90c31a95502974ac445e7917f06d5154c88c31e5882e14af0757af2717020061d3dc582a44d50322be5316a00921dd9119cec616449551e00625d9c94db80680d341f42b59df1cef58516be20acc05239f5e72f33609a67d8ce90a5a8ba7726787656d6a595e959cf97e3950a22aa95331af6d56b4a69104a634a24844acdedaac71c73515647592f5817b9e04fab1e65211e32832fffaf46517a31b5d6a372c269b238ae8aa417943cab338944ab7e50b627da6210a6bfa45ae29ab7a181ed173ecbc211f7e51045eb40ac83cb6a4be6d26041deffa8c2ad61a5926d6205ee8755a15dfbc59385b7f56c6b0caf31319ad79fe066e2c92496b61e8e19881031b7f45e00db716d4e42a27dda20acdb53587353c54f861da566fa0fcafe0fe7021bd51b1111ac8895c7d8dcae9826f2758cd89853d43778a34e89c21a244c9c02dd853b75ca415f27fff87edff3cdf75a88e4b3fc5535ce0f328244580d49540a8685273a6b909f48390e8224a129e109b5aa9d767ac8a577e07d3f8fa9a8b828d6e50ef9c2653f051902679adbc180d5f2262ecc6ab7436bc3c6eff7c9ff3279d7d37fd25e6f4168d0c3c0759a11f4239c918acc84a8ca800bb01dcc2c4db304fb47b4d6e9c55c47b331550b6a3080c1a28433c942d415d68dd4657f1d647964262363d24c24742b3065fc222bd83a90350f9d18792048699ca5d1c2c33f134c6a0d1543e3558fa6fa2b1316f5bc8287fa257f5ae006e5405501b785b0411a2c442bf749bd8e12ecb07e6c303f35c4c7dbfe0cebadc7ca1dec519ff1d6418c1ebbc7c3e543dbf38e9564c0885a72af6aee7153706279e3104d898825e18722a6b3bd2e9186437b2ae22d0591c274bb8956862f6b621e72a1ad8211539c75911f0dc2b57a17631d9ebb68558980d87ccc912c7e984d13f53a009719c8ca2aab490d59ae41523bdac011215272fc14a9849cd3050db69e0dd2ef2b20463fa4ab046174fb86ecc00d8a4497ad3be61960fc4178b28b9d7d421a782b5e84aa120c647c8f7ec03e4f4da403259cfae42aec40c6d313b5c011829bcd2b589f545c0e3e36846dc6d0f9d91f3f097e9e2860d17873f3dd464b978851615b9b9cf543e8aa7d32f16e0a690f2765742b4946af137d37dcb95a6dd8513469a7703ada826cbac226a41aee2c8fe8d77599e3324c5ca5cd268c622a59440ad4c5af338cb3c4212bedc3b0cf8e971385c05e37c1cf33ac5feb8893db23cc2f2157343aaf9fa07a33cc9432f9989bdfb8df3905aca080d83da0391c66c8c6dbfd52adb712c0b3aacdb54a0cbaa2519009e5639cd55572f1f8325a7b720905731b08b36ee7e2ab2d667cb49c2248982c5cd3e9470de7a7992ccf3f2612002c96009d851823facb2df0933a67af6c10cc9e58ff7c8c7e58cf9acc4db9db34aa1c307a61b9981ef075d9b07225bdec2d36639e82aa9a8d05328402e2009cbe1ceb0c4072b49ad1cfe452bfc0844af7ca7959e12f629f3f70204cd69cec9331583e850b03706b854d6c2b945891d6cb1cd2fac5cf364f6711a50aa55508c2b25c40ed425bf2477d5031ee7a570b4c76489dc6587d17094dc20582c6661458b2805e3b2f489bc54282eda0fa6017a1c1e1393c12a6e07a9898d3ee228221503f2d4f30902d17f5a776bc6f5027164d2e9bcf86676a96ea673fd9837aaf4d2b79ab0552f620d419ad3d520cb65e8aca530bfeb745fa9ebec34cb52d256265ba677a79fa79048cdfea8cf8099aeeba65e3915a578486c61f80e89f15bd2ba2d9f7a36b6abb242bc568f651049e05d98991ad8b705736dc3293a82fa425147aba4dac2200d9781a6b3d22fb76d400a2302c060651de470ba1de35ffd6b4e60d7bd2332a9c5368902856450f5e316693a2d388910179d12d35ff17062b474ba5c235a71fd0f1463be3395f049fcd34a2a55facf4235446af7c30ac2cc5bc1f3a1bbdd35c6e067ce1463985435db64bdba4084106114decb3169d429a634d2c399962c0bf681d5fb342719f3977d7ef4b376e825c31778e31a90d459b75c460007f90b1c9e2df6e2fe095bedf46c4583f204df3d747a240d0597e2d2f931d500f515c9981b813e5f9b9d3b3305dce28be814affc6c4de5caa9bb1186488bd4e207d1abc2fc585874f2f79735ac08aa49950f9244ee52b06a2ae10a363c4f9e4781622a4b896b7417dfa2d13c7d1ff5e865fcc9016896aa99fc90fd859c8fffac5a277d424cddd83bb34c0607414905a369cb88eb0999206f2cf1144ed31eaa6762ff04f57537ad64a75f80e85806511b054f4e7df87ad3f6ddd883b7498160c42c9d7fd2a2018bfb9fc9ebf7630bd5c91d4956d04a34c5d997874eddfa3cf1ad5a4a89dc1dba433430d7ae0f62790d7e09baa1b93727f51a65406112e8ef05b742b5dea9aea42b1f795b8a392d1c51bc803697b133861b622bd7b7da9afb2ec92477aa3ced1b675e8c7317c35a3ba881771447c10fd3de93b6f2650f29198ee76fb4f1b59335ac83399b66e25dca877b0f48d681f5b66921f5421f87be7466719dc70b23ca3705eb014e194a30d54981ada101b42daacaf3858f78d9fb3a9123d26ec68e0e84f4bc21134a762245b58774f87a9a6aafa2b5fd8e151ecb541fd06527978cc9fafac4dc7a2f16d30cec758f3c7a0142d77980746ca8dbb741b49594b0c91398a79bf5e30d9fc7cbee740b6ef5f4d90ee6cfab851de514eeb3eb95aece49030d3cd2f6794a7f5b68d8c933479befb66e187d32623262c69d7e75a72ce133d53b5827adbfee5f13781f996f98865626a30446e4296548d8c34882ae9b0591b01057b31fc3dfda6d79b582b61f9fe1a2e03200c2f99747d99bb4faa58a26f48dc283c3db6a3342b61f858c24577e071ea59d858d2c032a6ef0f49af4253b77b6a1c22ecff26b0dacc4b6d6314cbf80c62db4eb6fd5f49cca886d66c81d7196d8b8c8ab8093a63879c80b5a106c8651b08588a672f21a51c7be647ffefc5ac97288c11656fca03c6a04ddd3bd41728ac995d53f7d1a5d0b688a554db72cc4959f426048d42dd305fb82de978ac52e4e812004577adfa49a2d8d997ff589e2f638593d6c6675c313ff56340fcf4ee8111024ad8b71009f0b5e539246833afa5f52b324bc703bc83c7e96429d5388cf6d41073afb769f074c368d244f01b4dda4e442211eb86b7bca9ca58c7f702d7a6b7722573d8b16872b9993938f9f1c2b1cfb82a0906cf18331b7b67705dd89d34c4025a38990200fc8cccbcbf945415ea5d65f4a9014af099c0a7d4c68c3e695a168833fa21ca4505b857765c03dc8a113223ccc135c113d2d6ae2d7e275f3379feb042f617eaee815a29f0807cd446b7b1eb534b7eb42f93c0dab78fe1191dffee5f4d0f374a0911562c352369f9d66fe2a65d80f066069f8d7c20d765180449e41f77390e4fb305a599ac18dbcbb2f34f74e50c31d18845fa7abfbf96458f4fe107a8c6783aece8d8a5cd1a9fe66cf4330d8b16bac840fc82f7394d89798ea1188ed256db4a40ebc8e0c0dbe356e5bc7f92dbeecc5ae621e1b99b52fb6eae51849fa77e8ede4c271e01e5758233381ee4ad158ee70620a53431169c7ece18a04822b1adec3d50b9176ffe2fccef207b4403319c3d3b35897321d22092c416b48c35f5afac54cf61d7fdcf599cfb8f572b8259d2eb7460bfeb2e6ce65586109cecc9ee2196e921894ff3f1473a99942707015fc51722cee18234c5caed4f82e93910670ac5a72f3ffd2c4fc61d727e2aef3643eed4642865c6954f0fd9127a1d8952f1cba8b7e03f1068f917928fc2f68c1cc6fb38f06c5bfd0fb088a6fd11e12b9c9aa5290baa78d145b9d11a85d656ad006667614834799dfe547cab778ba9a0c18148007bd5cf98fc79f59daf12aec4091af9882e3499732d6c0ad0c63cddbc4d7a7554d14cc690b6ba034b4ec26e1f0f437f5f371de68f12f988a0897a0c1995f97d500a9cfd07a3472c1b0c473a85f711c46cfdf6505a04fd85ada2da18b8c0b0284b19fc419bd0feddc696e44037d8f3da136c62aa4db00940739288e5c06e68bdf290a4b4700ed04be63447a1aef8e58709dd2c5d7f8453d8d322dbc33596718cb15491c6343d6532fcdccb47eb98197b61d7628cc97a332f313b3ad52152ef74a887dec2a3295eb7c41972adc2b821bbe0c3f143f5c7395195df041c34d04fa32862bfa579f55cf56d127a98262d835b3d0aa5430d5a7c4c6f0bf8d1905792c0e04a6fc74e651c0e5510abfdebb7c8a95137d096cd25e018126dff6d5881df8d6ae93f0dc4ed4a266f97da3e246d2fbb8b8a81ca5a4b66ef37aaa252441c608355ad9e5b19902c28392876d3233d9fbce3d030e6d1d64590f809a9b7065a8a080df0c1463176f4beb7dfea1c207baec50d86bd23dc35b730eee2aa9bf603e4de6892591c72a70a2c96d7c9a076327","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5a5070a1f898b3eb7ca64bfa9752f7cf"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const {isSuccessful} = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4=";
    const imgSrcEyeOpened =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiICBmaWxsPSIjRkZGRkZGIi8+PC9zdmc+";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const {isSuccessful} = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
