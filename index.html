<!DOCTYPE html>
<html class="staticrypt-html" lang="de">
<head>
    <meta charset="utf-8"/>
    <title>Home Sweet Home 3D</title> <!-- custom: Protected Page-->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        * {
            font-family: "Kumbh Sans", sans-serif;
            color: white;
            transition-property: all;
            transition-duration: 0.6s;
            transition-timing-function: ease;
        }

        body {
            background-color: #1f1c1b;
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #2a2522;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #443c39;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #c98369;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffbda5;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
            accent-color: #c97f69;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid rgb(128, 128, 128);
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Home Sweet Home 3D</p> <!-- custom: Protected Page-->
                <p></p>
            </div>

            <hr class="staticrypt-hr"/>

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <label for="staticrypt-password"></label>
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Passwort"
                            autofocus
                    />
                    <!-- custom: Password-->
                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Passwort anzeigen"
                            title="Passwort anzeigen"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4="
                    />
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember"/>
                    Nicht erneut fragen
                </label> <!-- custom: Remember me-->

                <input type="submit" class="staticrypt-decrypt-button" value="Weiter"/>
                <!-- custom: DECRYPT-->
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Falsches Passwort!",//custom: "Bad password!",
        templateToggleAltShow = "Passwort anzeigen", //custom: "template_toggle_show",
        templateToggleAltHide = "Passwort ausblenden", //custom: "template_toggle_hide",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2407905bd833b99da8e1a472978bd5125b3133da8487fe7d2935e204cbb3414701db70db063b087d8eb23c8f8082364efe04f35bf498319a9470de9118f692de43a7f0019602ad513a9b39430db2018cadd5af3163a9124132d0c9f93e827617ec271b832db2e0ad52d5262b333988c95f2efdf872b8d911da2098bc4cff8204066302e601c47a790277c992e642e0d375dc4db54879a83387199c64ac1bf0f968a43382c52bd4ad26ca6ca74c90f32152b5804c0e06177afbfe5000471f10fb074ebf15c3c4957623bc4904a7dc9c7abcf52ffdc76f7658f4e1769790af78fce48b4113aa5687b13b5f14dfb6c479f7155d150115a3eaf4e2df565bf591cd502781eaa79202b08d67803cd5b79a12ca74c353cc04ebd76934266106cf03ac5712d204bf946014bd6857a11eb966b5c994ed66af6d123d1be34779c57c151710963eea3d3cc3cbc1499f31af4a5a79e39e6003407ef3470d236b00e2fa1a03c16bc50fd693545b9f2021a6bccda032108885a63aa5a957c96ad0e4e046881c5dc004f796afa50b401f232385c5a7396760a4f8dd1934e13d48af8d62de78113f45acffc701b70638600963fd78b13dc92832d54324e8baaebb2510517b1c13411d39311abd18a692d489a95e0752d50638a63d0280d54c75426a6b943bf2d453123a7ff24bbc8a5c9cf74f3d5e3c11036a3d39597eb58cdbe120b54b3a4b2f2076e99b677187b1c7d4fba35d0080e5dcb8fa5edf2d31c8e36b601d858710242df3a1c1c6e349f6d8b457c33c8a68e1d6467c4682f2b5445ab2e4d9e4ba2c88213a584d00698d655786f3e0f70d5cc99d86243c9cba16dd4d5f213762194b4f6702a30e449b79509b357cf7f0ad58867287bb24601c44c2f253db8d853c808a8d0a0d68571d3d56816eca275eda763c95721e2d3408b8408a22ccd21527d263da517446e23ce0529cd8a492e02be11f1a6752b767ee883d59cc57d5f17f527d39b1ace55e63a18a65a1c1e3e5751bfb75959a3dcccfb48362c294bf63d2c04c8fc6617387b3cd464587c062de499b3a0c1b88579e57401b2b3abc5b818ccf87be1816886b6cbc74c6d2bcfd8af39e3b0c199921f7df0c0f53353250db56e245c841a77999bdf0013fbda962f61df7ed008bbe2d76218b880a4ff0b3d837ef243b2ab0e3ccb168a2b49869611f7fd7c14f07f0bb3a13d550aa13d7ae22c4e341235850890bd5b2900e9f9b9e047aaafe7a2ee016bd873c87688bfa781adbe4dfcedf32f41ff59b8e0d602a1bd36f9688aa24410f4264114c4c86cce0113cfd2bba5bdbc0c6da9ebd70e985e6451a62b5bdfec373be49a6aedff3c5e5c166ccb35379efee97db7cebb5496fb02aa5b006fcbc3c3dd640abce93d6b1602d88bcc2b8d0f0a75e8fd13fea00ae46557c7d027c32050d9a3082ee72f4376ec7bf81aaf7c572c46e77f3c8c6bcab1d071e766bc5502b6276d60b88ed3083519391944deac199acceaf2fd56c29310a971d2ac1fda20b5dddb555de7cad4e94bb5b3c31c770dca9dfdb155449822388c0ce0200bf10c8c9ec85c5b690d9804549f3ec62543ae3221363496245896e68eaf2468066d4dd917d57ca4fbdc3e7856fc71e60a6ff3d2436fef946e3f2b18e1c57c6504634b5da7cd8fad64bb6834c7296c1e92c80cc6f7ba9508b40c977d582c259ce14eaf5ba2ef96c28477beeac332da0614d70635d1e5888044a319aec5ab36142e906577d36a34d8429aedcea7ff319db84052c96458a519779bb759c9f35f5e0e4f5d62733cda5a7f386f72c7b5cae2c4183f83edd3b4acc01560cd5a3ff477ce9072de080885b1c06d0262d2c475d2761b8d08b56a9254137be942aeccdff24894b298780f364018befe70f50695cefc64fe874ab0f02fb38115be473e6e7653855bb25474ed99cc46c35e76960387c57ba4b67b57f297fe19af6a5afd896a903b708890b0d46effee88c6e97c7e58dc9ad3b348a53757c30c955d8897ce2f19140fdf7a6ecae291399333a948799ec29f32db09c55d7620639ccbb13969aa02761816fc0c4c7401f4e077a03c79a369d359f2eaf0b4e222365c0e74e161d6eecd77d564843fe445b50748b5c6fcc0ec77fe6e246498248faa11eafec49f546de022bb60f56820cb2377b7e1878d72d9ca04005ff69e4f69082a6941aefbf3a3b7a4b43d4f23599387a6f2ff13b23c36ab0cd9dacc1cffab48cb4f9899d74e480e01a54efaefd23465202d554988c004c5d1963d3542262a797b255d7dd9612c36c3689d959bd47b5f8eb2719481fc70fb9bff13f406c4fdeac10d2a10f3c52792ba2b36940fb5cd458689c9d64c7e7ba42192f4dfed6d227ad03b156fc28fb50a4ff1453c9cf8d9ae2395150284c4db70b7c79146d4c1111d799285d6afa5463ab197437fb5812f4bfc0804a456f43904fd6b71fe466c0f64a6ed4f10b151baf8a62bd15d0d5f6c7428e3ef610510ecd5c2ac515ec483b17a14608d9160268a681bbd5ef42aef9ca6c34c2b72517b1e845196dc8da9e27d49a12f22fd28ac9aafc838a823ba3ae57638fccd95a121178153661c1d2172da3aaef94682d029a24ae679d8111b8e50923da4e621274c97e7bea67f768916a61b6e804b0431a575185d1e0eca320b168885394aa33b3e861f81a54af061485b58bd8d2d52c13d0b9e762798be13824be8f7c026750b5174b6fae19afce6d05aba197b149da844c065b14beb964f90664e9a5fe7d585ac271648312d91f7ca8d6acb7462e5d5c1e7aa0d93011d9b7e2af83de8b86641d8bb303548b86af8bdef0f7a286abf334448595b72e9af5058789a4107299e61758199d3aeac8a8ee76aa5db91675b995abab049581845ed247a9d1b78402bda8f7c8fb379a55f0d91b4f4b522cb08d215da0cca568d6c1c0e1f7007f1739cd8d9b9fb404315c38dd99975499f57c27d62eb49a02723e481de8773a9ca03d9cd283965f2ff4afa123b1c173a0c96d146de8d35833f8f2acdafcc12c4f7c568065824153d1a5535d2b595defd86307eda2e0aca98db7f09368eb00f3d1f1ac0269fbd46f11d4056373f987f3741ac87d80a19d3eb3490e887cef708333246c005d8c9fbf121c9602a9d862448681a43b915a79e2cf348e72ab02e8f74396569a6ed809494a2fbc101a03377081ca3ed76488e3c652b579178b1d1a257d47ceb3e7d9bee6f1e81f0e4e6654ab51b4817516fa0dfe3fd813bc7174b962eed0da55b39069610f31216ed1963acf045b75c20ba093b8f9bf05c06db0a42d972d5f4de416cecac26f8382b931b59e917f291eff5cbbd2a471e344fa28f97b7fd27c72c943e2126ed37a3ac8be39d06ed20534a2ce404fabbcb0f58aa14075be9ebcffe60af391d7635dedb1b2d3e6da0a042508646f74c3889e8f62c74b093a4b48b34de84d950d14a154bd07584ff9061025778be7aab3dcc29464f9495e71d53bea650d9b854f6b3bff8bd888f02b76a54923e4d98acd7319a371f87e636a2bca0b474f4672a12b94f2509c03cc9a70ad7c925554acbf1ce24cde11446a9facc3aa740186c98a6780f1304f08e3e04de5cf89f3f881b22335f9f48c9f848a31803eb1dc182bba19cd2128a5bbc1c9d4c59f44850d343cfbe46ddffefdaafb58abf18c195b1af31320c1544ccdbbb07ff974a248b67ba9d82ce7f8e975c7b6694579d4c722681759dbc06379fc253881d9289be04e99d44b273509d4745e9289aa71e246f9e76824d1311f491f1674e89364943d7db0250b0b6b40479b71c7201dc326e0cc3013000e19ac743922d9ee36688b8f8560852dc12caa2a3827fd4ed8f9bd393a25b9204ef75095620958e9a1464317832bab8b8e936f997163455bf7f8a7c89f57a5185698b992f8b917eec1d933c74fc2613d152d498ca3b7037c4bf61e8a35211baf533184bf549ddcb1ebd255842de5494f0b07027b0b5216cc515439e7bdbb70fcc8b0c4749c99b373d37a106469fca15733293665cb2ddcc554efba8c02df5a666d70d98e92b5737df40bbcd828e2f9359a0b9377a1830c7669593712d4052438967f6b18fb56f9ee890062c562195a3c80104a2b036e26d68a5d494b235bd158aaa3626771c84dfde77619b1b91477a14e44d60752446ddadbd79cd2d07436ebfb9b9bbc25769aa50a8e5d7ec209d516e4c4b0c6b2dbc942109fc6b81ea7c28b7e39e159844648b1cf8e11f50dfa055d3b9fbf948b84c7d31e677c1a3b4a59d23316c15483e6c1f493bd1bc1456f1712216870d7961b6aeae9cbfac092f5bf8ffac6d1380f23605d905a05d704a0c0c34a4740f5fd2bb5d3359fe370869a331ff6d3f1da064272657e64636acaae0386d6232a7601c94f29e25ca3cf48b510ff79b53d2ff3d1235ac6723c441aa058e4a4d9248b7d7f3a9bcbc3920a7e6f905faaaf472f59aab0781195fcfb84a450609bf36b19bcab03efa2b412b5a20a4db290f872de663f838e2fc603337e21d8870a40f7aa1ac86446f5722a4c1d3e1b4ff09429392c70a5ccb4628121ce6deefb71c5b368a6eaeda79bf1128806932e3e5c42ba31d3900368828dd59e9457779ffe336bc8ce265c8f7b920fd0ef0da3e78b2598ba45e7759b379ba9bfc25f5588815be2c3dac605ff6f6015f5f67294185cc6e4fbbe8de6accaa1fa0e4c23e57f2e30ff15921a6b3aba2d710eea00b560469842ac624fbcfd2f7cacd977785c695a6a1ddd4a7a333528f6cb31831449fe9e7081c93587cd77b0347fce5ec10b9bbdc51fea94fb61ab6668e6abc471b1d9c558ab1253753313373bdcc1bcde1ce08cd719cbcb741a5f0ab8721e5426990add5aca4a2b6e0847ea2710f8a74a83d8907b1703361f7771aaf54347b833f2ace497eda1679ba6bf33318150c5fc89b62e64db14890fd6d1833c4742a88b008d97c1be3453cd3d067afe935c4facd5f7f8965b5d2b0f1fecc62bd4e29e4ad813bb26dd945cb76f3766b451e58b2ca0e9ec33b521bbf1bc09fbca02efc51482cafe12364fa9263d0b083d861e74ab5b659e223c48e8ceac6b8022cc84a46c5c15d73e2c402a69bb87c477824c0e11d81c36309acc7d945ec6420335297592fea8011780744cbc6f31662a887c878845c5b2b6bc42a51bb8ae628c9efb6fa406805edda3bd9570e5ab6e0cb65d50d6562241763c822f36dbc2626de3254c42b68058fb9f2fb8002a4db3efd935e6a127603d01e2f30c3f061fe820df426147803510ae0cf11d98a0c369bf14af1b1dfecc4351bef894d4f7d7fbe7804d1fad17989e1cbd746cf0ee42f2cd68c7fe7ed5a14349842447a72dd8ec42f05ac4788966bddc054547d032a377ec42ce1099b22f20c77fc839c28698dd50883aeb677f4b23e1681e9676e18fb6881daab7dd1d32243394b0405b424e7c178260ce9482bc2390eb57059d343a090c2bb9c2e1778584673bcfca1b6c25846e95ed0f200e2dbd030efd38dd2487ca22835d19aab1bf409aba535c877672514c13de8308e215c276b29c265b7eb71cec765bf3eae8ed1f9b92d5d3b8b9efa011573bf3a28f74eafc89ccf8dedae3c488abcf7d7dd99737fc408935d58ee263346358b16fbf60a19ba2ccc1d92c56cd706258ec458a8071b2c7ab7a935f70058208dd624e31bfffc88626e7ab32892f6ebc3858d123ed0baa9d1cac238e4125b9e6f856379cbd4cd579f2e5573081df9fc5151744d03d7f8e543a875834537adb1c8b164cbdeb47da93f9e221da034ce6c260794ac4b1736b75a4cac38adf62d1bccd7e597e1f34d5766eccff91919652460f8b3cc5d5c6fe5b20b05ed63837db8f071a79bd8aa28023aeed64b8d9f847dca8f4cd09ccaf8ff71f48cc2f32a84198c24813cd936fec1560f1b4709d2db2824499cfaf222127c26b9e3535c1fbc1f1a8f3c228477ec2b6ba20af4c38d3bad7311b02d253a90aa756994a48f5ee1f003abc627f78df2e64fa68a9b123541f23269ca04200ce7dca0322c10c5e1ecc6f54bfcebd2dbbaa0ffb5c0c008e10ca8350d9f93c2ff56c4546444b5579d5a4d9aefa1b86eef67994be5b95b50add8392fb6aae423f40527b6ffaf2dd191c6e6601704b060aa52b5b2b7c0383b4ba148acc01ded7a7f926178d53cc8555e87f6f660cca10dc1a9a49143752aaa48f9cd283e37716f62ffefa804a22fcad6c75a0c2844c7917b6a05dc7c7ee7aa4426938445115200bb180fc8056fc47c4614f4be12eb06824f69dfbc58454020ae12ecae0bf374f1812aa512359d9f70df7f2f094c85856bbf031aba379f2ece545e09cd9df3880f506fa25374651514591cc9ad3f3726dce2cd1560d723191c527977c8d619750b2d91d2615172bb55a2c1be6ff4f5ec384338b5db88911d1b93a75f187fb25213752c57e718dbef6c501317ad3de1bcabe90188ebce334bb20e4f78d39f058bfa9a194f4bb2167da2b3c7926c38cedf618512b31ab4070914bfcd85789e5c4720d01888f265efeff8cbda751b58521563131c050fca54a1f05bd5d33266f0420f4930b0ee5cb43699b773f09b076fc8514320d0d0910094a26542d7d1966f28f4fcd7a1a47c1c3bf2e1620044df9f559507dbc1cac7631a3e16b2c6dc796b692e408c32d056caa079876fe5741f0f492ed7affe50b28704b57fad360d0303969be5dea4cd6f072ab04cdd58a742fedc69a63151c1c7487498c65b77b2c0a80811f85773351cec812d279ad9270534047a01293341631cdd3934898dfbb13405f5db756df97458041a2f04a277e7eb6b55d921c8c8ce11e0bea1404a6fcdb16c1a7a55d79bb30a7dbdaee6b91006af22d997f50a8a358205b4edfadb285c3beb7b9717d27a5a3750f58605ae27c5cecddd35eb2770b2d421b8466e0756d0e9a765d82f6c58d2ad682d791088f005a2e6d0f0f6cfd99811d6f598bc7002ce8ba35bd5c138c13bfeed53535db02468f1408ec3acfdebba4d8f7972abf499bcc2bdc34156ee987f4ca62ecb2b60e735fed246c4cff129dea0950a2dc5a27f9f5d2bc64860da1c47f7e8b8ffa8e7ef1d7b9d8cd3bd650b55b01540209721c7d5aaff81496c835820899c4b8234ab55a9f26ff1f645b1f4a57bada8c6e5de4261502001f5dfbb3358be06088511355207409abcdb3f324d1394f867a7fe90ae31165de47f8aa0fc8d392eb085a1a22ae914741bbe6b80294dfcf2b968989c858d37d2fc7dfd8bc9d927ba0605d37a0f18b672a7c66ff15d10b8b099f852e54b8578645c0c9ed22a573af49a276a2bb8640db398874e7d04f806b34771d17a39a738c0f625a6d3d9ea340dd67f1f08df952f06d69764590875151f9788dcabee90a4d034f992cac947ea5a41d45e6c9257cd7b6abff28ebe4b29b01c9af7eef4ee4d5acf86b0af5d056eb2d52d6ffd0eafac5ca47485f48c82c42f6eaa4f7f553e8254630d99ad74baa86fe97fe3c089b3aae00172bd08ef2f5b582cc97656917c4d843d9a11e2127802903a46856ece2b4ebd84367e77fb15e03d15bcd3062b6a6577628f12f8d9340654bf4700aef9c7191373f0e657231b26ec773ca917fd1ba4395ca0ea6f1db6f7573eee00eda4df1b9d6c31bb453a89b5cd8e38227a0a1706d5a0881f33903ea58903daf67f8eac09bca5a013aaac3dac94d07b4295981e40ee6e152218de5d8f08cccaf802240a1d6bf54769486c5c6a55b6e63e4ea8a876857261793fdbeea64cc091655c81b5eacdf563a485238806793dd261f8355e211930b4059b579339437b697e490d5a420dcff58ebdcbb3edf5b847485d0416910b0dff9336b0e9919f90e96d4940ffd3ccc23bba15212bb60395a5e971cf92c0315cecefb6fd56df864dbf29a5ed7007bd59543ac73a74c5703c6d39ce0bdfbb3c0517285ac77ee5a9900dbaaaf9ca8c2939382b52fddb157e058eaf385bd0ae620f8c640a464981a7f98e02fae856f1c6d7588b78e9ced7b20484abb4a9515bd45c732b1f546dc4f4719d24ff1bc2bba1b7acfad8c732b8c43c8a753ddf858f8bf57a1a1b87b264c3329f91da0043b048154baa316e41276052ff2f90cb8bdb0df6ed4188db7b0caf5f335009453cf6851f1f4dbb583b2cd1928eaae1cbb7d37a6ee008c088736bddebc818a1939ff20b8ef78e61b3e73ca290124a7417648f9a19d8f6c2ed258fdae72be0dfcd0db695e12fd23e6d16387319922be7d354ba20af5f6830339565bade28fed37b4dc2508a1a01043c49caca5900dc7bae397fc7ead0a7fe46e6f10bd5f40cb6e29511a01990c82098b502f8013db1c4eb4df289a1f630ca0da30a856a36cca4471c198ee4eb81f0bd991d180d7e8dcc989dda7350f9b0351093f8c08e413b89e50f15f5c43588b5cb6f00183bb1fc0a75cb602f62806b8a834470b0e120fdd803b1456f2b0634e487a504a259221f851d58cd264198e71f22a0aaef493e13c20e1000ee03785592c284448612bd5cf8d0436d98ccfac36d15a19bba0c10054551449540d97fd3a0b8688ac5f15ebe3b2e0a540049de54ede91d37b1b34edfe1543c611ec6f482e4d17b48a70256a4ff9142f4a75628b1377f5f87dc6ff644d61d1783d9ee115cfb8b6136ed3c246ad9e16a5a13641b7098b48bbe7e6cf79069c4aece88525a009dad54058f37679aa4eff07c8c00de38bb15f4269703288b5e2c2d6f7d319cb657f66e2cfc64f0d455d7a16affa162c09a842d43a900ff7d91b0afb337f8a04f3ba6f668a39f157852ab5925a2e22454cc41ddd1a6ad8e8cec671678186bcf4b11e81feef44ee5fd5c0d5e7981c444927263ee45c3c8cc6519a93bf0935ee86f4bfd9cd1c7421686c84336e070dc8b338eaa0469b07b774ae4a38826005beccb90be6eebab797f6ffe82c5a6692722640ff892f2e3a556f39a2d1568f06abe0d9f2a74a8a1bcb8724282145084cc9dcaf5e78f7fa6d94579358507272f7ec5062945fb35f4de169df15ff04333b8041248ce229e1956cd98b8ea6a6289e4ee1d43e0d5a495a036954ae8624929556de375163fa291c5ef82d5150846bc509af62661abbec0fd5438cb8dfee2036c08c00c853bd1eaab1d5162a86d56b595d0339ada571f83c21c399567ad7f4232207f069ebf1e66863ce258c7a3ad1ab25acec8eaa1bbacf880f3da889d8bee9f8535eb83c81d7d989857930f80d12415afb70a6ff98e44bcbee716a12d182c25fa08027568eae88df4946328134ec02d2e9703b651dd9ad1f77052a9bc47ec79177c34c7bfccd650086b4f4bc4c28ba9883d6b725a31b51dc7c886fbe95382130715898f167d997c7dce0f3ebd245aaa0ad69a66bf6228b1075fc1eb7d30c2aad8cefcc24a9859812a34ca28ec2e4dfedd2381af338d639f6d860a4a7b2be164d6d7983465361ee8e5e00c2e832e1db2ae5df7af70fd9db498a871eabf0e32cba331365558f843cf0a8f6ac0a18861d59a13cfb376c211c32ae230c529cc88df053b32f12aa5bed9332d51062e39052d3ebc82e9d14d128b7b2c61a7e47ecb80acd6a1712e6dbbda284a18457b8b441183f838f46ce40c04114cfd95b3c06b5c3618158b819d3232cd7d5a401f21ad54c5c65688e2705a9c29342fdd13d439eef4a8d77dbe0a8b91484e9f932fbc4c701515271fd6499b7d6fa9628fbf39d114d6d247dec56f4ecc24f1bf4b55e72688861dbc26f3ab64779c377bc2387b0b90fc005c314d19536b8a610216d1e7b7f7659490e6ae488c8a5b033e9a670428e2283a132c3726395c5d4d59592aef865c4fc3dc826c683483da60d0ea333d3323ad5c5aff8155dddc1cbdaf071a4570ac4b569cf12f4707203a87e793603243bbb58774605fe76853075511d414e0feeec5659b445e8d96a0c62a7dcfe82a01119308b26e6e0a7aa3c9092a480f4bbc393c63105b2e8448137e6c956cab597239337242456ff8c1950973adb869aaa00d1edd7271030d212da0907d4e0506e82f21b443d4c7341c784b0836f4a00734955e85b6e9d9147838e61b719fb4d958577cbd545662dc8f608363cf89073569407326b41999eafa09f68bd6b4fc155a051cbc81893f22d8579149a6298c6e2d3dca336d011422cae1e9813d793257d0b19ae88156ed764fbac76936e70a6be80d9b5ddef9d5a0df4cb85620921115c2471de824192d73aa118c9e8c721c6b6e7c1e8e4d9151ba5366956eb4d1704c0f1b4d862346cbc3510f531d87d25c99d67c3dacfe504c825280729e89a8e986040a07a83a09f2d27e7d40861d723e719d77b16b0051d1b6c154ab7f87fcdd395e3a074683eed4cb10a41e119a9f8b66a237f22a48fac4ed68449b8821111ce799c767e9809a3296f3715b4da674b30cb23ae049e1357fb9526538cb35e3e9d2ad21fa0d5d175a5c6b97e5443e56d40a9f41e3c7fb1f68ff63b516f280da02edcc7375b729fa7b032fe7f8708a1580d470482352a468e00bc5484377954d20cff26c138ec1fcc30b129cd92964aa283c97fa010d257e460424bec85494c2f7379b34b20e468e7d852c0857373aa76ac2477c9cc7f72ac10b79ee3a8f5f3ba9b7d6983b957f8eae42a5c8c4594b3115bb04a7f0058db892d889429d4c093e5942eaa33b8863939442d51e848b88448bd27584788fb305e510a54b0955bc025dc5f60e006f904e3e6acc536f453092d0cc1219d80ed4bd50f4d77537fce43e769f39bc849fd5c6efd70339c365bd624c435c8db596206bf5eda4651f5fb819c364b27e63a7bfb3a6bcc9ae204308f077c4e8d5ad714aaaac45d7d4067e67471cce5a09727b8f4f4bf9873c383ee3e05bebc91704678af35b2b269b70f34d1fad65eb87d64c3fbb46c13e8783837d5dc6650711a6d2b4b95a5b9a7810fb1c04d2ef1bfca4c12712a933bac8aacd354b2bea1434031c0a38630d91a6733156ab1114a65a651da56071ec4a54243b454d795fb57d03cc8e18898928ba3d6d8a2afa4400bc6576e42a55274a14c19de6fabaafc6f4f7a802f64555c0239afbe00266aacec6aa827495420c85524d487874a189d570a9662cedc997f19552f4d9733f4edc639d9ee1bab4640ecf03a03a27cb304540c0ed362aa1ab3fa0f6e509d6cfc9d336100cfe20a007276e8f2de62823128022c61e50d0e2e6be66fcdd72e423142fe79be7cd6c50c177467d089ed090065b84677681a022bca375960b80042204474eede2b28f36f646971fe7f6bdd1bb96383af413ca79a2f54d58e6b2726b6bdb4088d20dc15924f786354a7c5b36e0bb930811928b099c849fcff6a2b705d9fe8314fab9bbe14b67dbca27804675a8da5b945240830972a8e5f2cf6d561d9b8ac1a59bf2fad561664883a425783ebd6fa17ed1965a9d7f1cb27cacba263541ed557936b2f31e80c34d7fad80f615e4530184672d89c8ec6da406f1527ca12c078785113ca544d8397d2de4cc1515b9065429a1a3a099cb5ad062d2f27335984ace08a6aac5cb6a0aabb1bdec75db761e329fe9dede757aaa92f2324bf6a41478e066544ce88ac4d009d16b09cd127867f1d44c3470c6c86ddadeb1cb24d028bebbb5c57d4c0511ecd9584fa5436f947e85f34d936edd84290973e13ee09f4777d3a8b3c63756a768c8434d1d090c1a542816c8dbb4bbfa84e37ae768df4bf2ca021544a80c76a2bdc273528d895383b11eadbe3e0c08acf1ff0151baf3be9150bf22ac3aec9194f05400cd859c69188dbdebc427c1f6534fd087914cd1cd2a2a7b6b16c799b898fd2e184196b6a7eb3ba89947897342d9be91a53f0ae6b01f3f669002fa7219508b72e5a5289e672e48b4c67f1d933e6e70b1ec45bd0364a8f1217cae84c1cc336c967b79266ffe8c58a55eef8ab8994103ee6941fe4d2d0c1b1024fe27eaa577df1303fbaf761c01065dbcd8bdeb4506fcafd97d1d16e5793b73b173ddc23dd5f5ac6ffe95e2d3d15f51fab4b4390fe0594a163013537bb86df34b15bf14cc35c811cf1c508ee1ea0d456402963998c2e1716795aaeb4775b39d7955b679c929b85afaf9e6e09fd02123f223003866c36d7ac9a038ea29ab86f84b1c924bdd18f89abdcc7147ecf03e0c5e664bab8688861486bbe254b65f9713390c7a9e84a91520a823bd473989c184ea06e0a73030e22158d5f045bc4075c1ddaf0a9a6e89cec7cc842363dbf816d5e05c8146b6ca817f47385a8c078133f5452af60bfc800a243e42ab97c8b45ff34e0010ebb87bd6335f155c015c8e89d0f9bd29e6924dbac08fb34287af55252708b4810e3409ffb27ae795c28c5ced4aac92042ba830e7d2c5101c38a42d53b4747bff0a824c2aafeb24dc73532b6c5a750afd37cc5a2e392128554e28e272417b4a968e50c87110157d82afcfc6f9890db36ecebdccdab8ec905dcc0e82c58dd588b30fe12c8912aa3bf08dad6bf6246d2742bd9d2a22630831062b1326024e2269363251bdaeb4bc7dc80edcd1b9512f185b9e0944637baec1cfb072b3dfa2ca923ca67ddb5592b244fa8f584c382b13b14261ea3b2f636030026b191ff65897fd887036d8505754ca5fe699246384f8d2c4b31266a94a54cb1dcf5f97fc71eeb342e457f845ba1d4509e398d2516ba1d0680706745ed3b369f8b2dd5ae06021a507d51d1e1974a0803c941a172490ef9f5724288aa7059c3f06fddb82677cb67c58b36ec8ea0c791340f98daedcae6c13c8f7aede6c8874e6f9be8d0576dab0a27e61d9a22c924fd54f533159e441833e469f8b70e38795a598908bc41bfec0b308cc4cafab1788cad952199ff5c21f50c15ca16e10e3d7330fad746a15f1cbd5daf2f63a8655464569b2cc04d2501e409ce851554968320c86f71eac1fd36eb1bb25a5ee91a3958fc01d1dff420edbbc838481cec2168c9fa1035ca62f8739c2c3192e8dfe10af317e1a140c96e0314f951fe988b3f3422dc0ebbbb72834ea93c1cfd390780f7f5443d619702d58e4cde7399c6d9f4efed88c0d81b87c5d5444087f7df68302a08c3c0a27900e5b2384e06ea66411461e76d9909917f722bc19264e24d03127264fd8bdac826c07be3a95874d7f23543f6076c5d5fd4530c62cca0bb313ea5d68f9a37a3fde7aeeaa4c5f254288629bedbbe031f8e7fb652ff807804e2723889c5fc10fae09192d328b6ea446d310af138805e907597ca8b91583dfdcb7b47692698e5686d90a94a2b123a6ce675a94b8df830376040e7b8b05db9e8d81c2bd30b6814cc4500673a4ceeda313758d7ea3ab0696af5673980017c830105077ff71e02bec05c973cbfb828c2da1eb9bece570a83965f77f4cd6bcf62f91665f68b7c7e7404ae0003188cb6724dc81bb9f7702bd065d4af1a96858a815211b0bf0add2dfa5ecd26f1cbf8156551af3a776a9fd465a4747cee8bc86e09427d057da64187cb13a5177d2b299e7f7ed6cfb4c3e390a5d1ddd034e1a6e09b5f7f8d681ef0740a9b171434f6fa99c84a82ed15cfd9d86fcd5061ac7d0428080e1b1d333905ea47d021ab6c66b872398cd8292dc0a43b9900aa1ec29d77b135fe82094dc1074b9d87d7a3b625b507d286b24399fac35bec43b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5a5070a1f898b3eb7ca64bfa9752f7cf"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const {isSuccessful} = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4=";
    const imgSrcEyeOpened =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiICBmaWxsPSIjRkZGRkZGIi8+PC9zdmc+";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const {isSuccessful} = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
