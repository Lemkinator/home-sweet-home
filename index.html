<!DOCTYPE html>
<html class="staticrypt-html" lang="de">
<head>
    <meta charset="utf-8"/>
    <title>Home Sweet Home</title> <!-- custom: Protected Page-->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        * {
            font-family: "Kumbh Sans", sans-serif;
            color: white;
            transition-property: all;
            transition-duration: 0.6s;
            transition-timing-function: ease;
        }

        body {
            background-color: #1f1c1b;
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #2a2522;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #443c39;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #c98369;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #ffbda5;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
            accent-color: #c97f69;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid rgb(128, 128, 128);
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Home Sweet Home</p> <!-- custom: Protected Page-->
                <p></p>
            </div>

            <hr class="staticrypt-hr"/>

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <label for="staticrypt-password"></label>
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Passwort"
                            autofocus
                    />
                    <!-- custom: Password-->
                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="Passwort anzeigen"
                            title="Passwort anzeigen"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4="
                    />
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember"/>
                    Nicht erneut fragen
                </label> <!-- custom: Remember me-->

                <input type="submit" class="staticrypt-decrypt-button" value="Weiter"/>
                <!-- custom: DECRYPT-->
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Falsches Passwort!",//custom: "Bad password!",
        templateToggleAltShow = "Passwort anzeigen", //custom: "Show password",
        templateToggleAltHide = "Passwort ausblenden", //custom: "Hide password",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1b82fc73a667863d1c05c41ed7dc60a130f059caed6f9970b774e2e00e8a5da91c569c3650a817256e4ee89c4bdfd463cd7630aaaa420e1116bfc6752b6a13af9aa72908cb0faecb3ebf7f128351a94566f9314eb1d8408b545acdaeb847285471d04d4b22474ea520189e94877fad127894a90635dc0a827bf26a13fe628bf49b0f0a9c9394ceb523e5f3d41c525ef8299def3b0031868e3aaf0d47f931927c1418bc695f82386a16484d52d09af7485ba4fe97a45e3d2bb735f1c20bac0dccbfc4e611c0b238d51eb35ee6bc790ef1e30a54fbb994401d2f7bcaa0b991103a4adbeceacfbba1a93226d1c90dcadef4dc93de8a574dc1a8fd8c991655628509c2d2c13934896f0e8015f107ba8dadeba2b01926756ea2c1ca08f3ff9f0e5ee11030bed37dded06af69701a62629ceb139e2314b4bda5d4e9026c1ee8c077652d44b65700aa9b5e5200656c80fc82964839b756e69a1dbd73472e49cfa55b6ffe2204da4541193e0fd04ea0cba1c6b15424af9e6d94e31ab73668f94bff993287ec60cff2ef3d26e5f44887c8daf9226cddad1904288e34174b06d5e664b547d5640a76035ee3e46bc6bcf6bd7be116ba178dd139949f434b7de1d9ff38404bb1eba9307a0dd42d7e2291aeab620735761d556ec3c62088bd90a1a5ab29d236e1ed5991ffc06b9dad71241c73067df73c41abc486b49bf92734867fde877cfaeff7ac794cc12163b09261802c333ae56570339f67274b7d92a7a3b009c4522584451b4940a6548b17cc7966594f7f9fbdd00831233e7b665781a352f57e0465bf806fd10c0339d70b97bc578f7b8636c0ef2870286b72db09dc35eebd6e9fba22e3a9d1e5dbde2d15a4a63bb4f5e36aab9bb7956c0170332705a45a1be68048a7900dba0830b14e65c4e3a50c9edfa8dd17b1f4a9f12da5a693abea687bfea6c343731694f2d7cfd6c417852f91a0a9477fcdbb327c182ca59513328e41b851bb94bf996796dbca0a878fda5c588c53a1aef12d647ac2e4c6b0053024722d9a04f43a1497cb112ef5e310863d81d51498b2285057837bbd790078454272f957ad3f4ddf3689d400e6bce696f11e2e834a798ce490f08c2d6ee3e3861e0fa6ea45fd4a772be46f1520e80f567b4626e2a1b1ff0dfec7667a4fbd64165b7f847b53f2ca0b7440d7d968c5f353ec12055189603fb4076a597c29dfdd711796f87812617cb1f68e5be8b4f292fdab3b9377c20fabf70e321daca20ddd5bbf10f0300b3e4c0dd91df18efa4453f555296ab2da67b5180b498ebe147e987a7fc65d95610fa5fb8644527e865a9be2e9bdfb6a1ff1b0e02a3340e59c374672d62282d1a768ed7d5ad949db21e980a6e01bf68b1328f72f42b4893ded1561772e7873d329218ababbfdb181fa02aa034d03a1e9027f5d3c9d378b6a1db49a5c2a202e855038a0e6f3328d7f6b54772e8d617cb7445588ac2d33c17afa9c8b534b0a6b7a09bf20891c2ed85a28b6827168f54f3784cbbfdab21e889e96664e45410fc78cc776ae622aae7e7d2df5d096e5aba4d0b4ff75bd567ef96da1d28593da70296ae6374189ce6588e220b26fbed43a5fc73412f34e2f953fa0d2c844dc1109890907de33d6fbe42e56c7abb0b40d12775b3376bef97296406c1f303cd61ba49135cd26ee4f43d2811d2f60914d108c1d9ab88c19b360cd1b087e85f8eb4ff5ee2476c0927c29807bc181aeaa6448fe75d73726293d1076f6e0ce72ea20dc6915a224964016b651686194bec7bcd4cba376bc5c5b04e93c3818b0c0deacf0346b7f021754c40bed5395430c5e796b3a18818302d7cd3e8bd7ca2910e942eddc0802f6106ba5d15634d99796d03c4467b10874e54e7a99708c7658edb5ae93a17c5a147dd0cc02647ffda0a007acfa2dd6263de3c51cac36e06423d18ff18e4795212dd1c7a7967b130f32b5dd068b09acb3eddc58fb038f15174c3cfcfc1106749a3a2a8a2cf63ee8953005aa5a1721e78907899ae65312cfccd970f5e31193cf876fd4506dfb9273c282345bfa1e938a8223d8d03951e487e792bccee48b5a1f62eb70779b4eb659d54099201c6a8dcf583ad6ad1db44c2f4d3ca48116211b66f2ce50d66aec5461c3457e7f04588eb5ef1455f90689621c93e1b897ac29405b37228e0ff0e3ddcc32d6b3ec9cd51a971836ee843d30e4877da2fe088e063dd47c605f61a3a74fb29e8cd2ba497ce6091ba8e635f5d254479a248b1f78c62fe7121dea466977c443876c703a6e75605d7a132e968e375eff4035a588a6b2a6463626fa33902a37b1c4d00c5667353ac0b19bfd59dd0600231c4eb03313fce3d89b0642f13a76690fb3b0b7eb947aa3d9114f4d0009eea692fef5d3f2d4f02643d1a4909fbfd71ac7f4b5ede3abb79a904e1c0737bdcebb19d81068060c2006727b6cebae1d1c73a96a0cdd1786e27c442a3c489ffadb50f19d23b2656ab05a4c7b25d722758a5c66d72b6cd1b4f68256793537b03d75afd439c59d54c86c83aaf4ad515bbfb82543b249b060504e0473cb8134031277367505c3cdbb2f36c661d0dbfe2a80f4ea0efa431f9eeccac08d28b57f96fb3a5a2cc91f0e45e614e336fc603fd6a645eba48f54bde6bf069aaa1709f150c74efa449006ac50a2f224367666faf27a77991105f4bcaef116925b8b18ccedce62e8596a8d6683b565ba79a9392e9e28e3cc43a4deed7ee72070cdbca7a27322d64483a5e3bf578767f4e6183d50f9de5ac8a1df82a9a4873d68108a77cb69d1c9d6daecf90f341cb42d1624302680713126552e6e68b17416a836fef32c2144ff193d117054806c656de4716466e78c3bf7584c936aef95d6ec8467a63c8a79cc0c3e7b23b1c9c6b0a147f0f445be47d0794dd595af8230371b4cf33f032c91e4a6b61fe19d7d117906a119435cd803a7914f7399702667530054b8258b4174befecaa5e4f7f960de6469d3f3d554aa080d8be1276d6d87090b8c6caaeb7ee9d11ef662dc394ebf22e440d813ddae1d6af645f274ee91a715d53b51b0bce9d37e534a5bfd218725eab6d8ed1d9e1b2c8c70a7589214c64a5214ec13a5cd524870797b29c9b50e7d49e32a80c0aa9f0becdc5ce6ecc40fa3f4851f2437f816bdd494da91f9d2e6c2fc469242fd25e115f6a3bc20204513059a94c44a0c56b70cb7f4723d98b4b1591f0cf9c92d5676679d98b28eebb160844d65d521469fbdc6e8ad9403dce061c8fa87a35dbe6f6ada0afd16bb6538ca4b48a32c48c85e35ad3e5013650560f837d136f03724be2980ce0a32b78e0717aa0c979efb90eb565c0e146d9ed0e5406b815afc6a4c1e23ac039631123adb3cbcde36c587e50d5e7f245d27b2b5994228e2323c8179240a8295f0b0ed5467549b9ee4940e4fa866ae314f1e41b7160ba696cf306085a51f7a9e71516abbf90b91ec28dae8ccd060e3947945e2452be1bbef95054742f3179f12b2c382fea814464ea61a43bfcf3bd58430134ac4a5760de8e046baecb3b3ba3f10237db68cc9076e11d46c6db2eabd60c8a7fe41bb855eee2e47fd559a37a6d1f7375110fa67bf0b798ea01ef3a40f1103e4c62701213e2e98eb2d74f820583633c165d9ff08355d16517b8459f5c1fdfb9091b11b17c95bed77f4bcd89675fccbf36afd26252ac320e060d86e1741621fc0aebddba39699184a3a05c7f5f73bd645209fbb4dd1b9e0e9e047fec08cf76fb76b0f597456069828af143a9f71f7d5692626d3f3c5bfe2557719e47e4f5279d7e3cf0464ba672d47150de72a94004741b36074e3ce0d0153e63a5fb38fadea52eb816d10d38e13d5eb86eb2a2e9b38b31b8a65c7d385a732b27b315180bb5258120f762b85e5301ff31f0a565a15ec9c35ac9fb0601f113cde3a94bbb7d1e96233cc5a4dca72d1403dc746d85175372c698d25851c665fc6796b4ad0a3e3203a02f0854ce18d31781c8faf413dd25bcfb9ff57424b2845348ce0cfec787300a592e7ac3f27ce44e312d61a6210b5aae2ba911ccc4825af72ea90ce69a5c22fb8630d75d4161b4b1dbc702dca2ec2fa433aecdb64285c2fc729042473990a15cdbb737713a1c20a2141a3c037356930b0681976482e64636d83e733b98b4a32c5dcc4fe2b894baa17e94cec7813f7a86696f9a14582e141f635a7970147b47daa3bc1102bfaec6f4b1c9cdcfce7944aed5070737b1d8607f9aa689c84b7aa594dc19e44d73e6efc8ca0eefc881d3557b6274de905d7ecad9adb7590bda0a34acbeb723828346887d83009b7fc4ac3b16ab120294ebac2743b886d5b51b082b04ebb32a5c44c072ee554292bfd9806b62125b37c31286da827f801d0255575362ff4a52d0c07fbc4a42d3aa7522d342b6901796844c5fd361dcf78f9efb9ec22388141407850e2952c766592f8eb1a5dad105c6129b01ff510cd6c5b0be0e7670a7cb0f70552913d5b57a8dfd5d5b8d50435aad41a04112a1e0562c603f86069b3e712478aad47fa436c7662509cb06b7720e492f064cede14d371cffbe129454033f9135e5aa5919eb7aea952c3028f51fbc376274788b0e1ad705e02f48a39b661d7daef7a25d50602fbafd4f7c0520e58cc862519c1e5438732c0584a247ea43df32e4154996084cad338bb8d242feabb5fdce98241179410a30837e0affce6808c7fc7eb2a2eb6c477e278d484418bc25e6ffb1ebfb7b96441db9ecabc7f5d8aad40aff6e90526ee19b97975751fc9e663e328618a9a45528061fea2d2bf1db46464d3f4a3076220ccf2ab0fa3874ec2346d4e86baae345a3c04d56f028c09ce69f700aecc1ebe5e3c57e0f633d97606adefd41fef0f3c3f77b862e25a9158f5a8ef9705f20b7c2604d913260498faa475abbefdd8a61903e95d27f366de2493a939ebc83e731a0359ea1f06c3361f3c92933699511da91edc17d03aa00b5839117aee37c6a1376687cc3be32d85b767a771b2fbebd2bde6778767726f3b2b9bdecb481bd7278de0feed29b4185c76bb65635c9e2b5f3bcb290505ed21c409c07d9ad9d8bb891bf9326cb6f5cff31b24ee8f0b07e60c422e8538d940444f3ace0d0968770b2f43f3b5490782c8eecf4cef5f0932174a3359cae7710ef12303f93ee929320cebf43052a72bda178ee5c5c989785f97082bf08793cb0b3322ea8764b4f1d8b2a1caab615a22c47ea1c15fd3f235bdb9ab4183cd51cee1a9c2a1e2da6f98d9564011e768d9f2b4c760063b1ae0a162dcfa1881606c7d74c4ed3c25f66eb7d8477b368e7ae1d3d236e3140ec3e2bf3e5397562493f91b5eb1aed6771c06a23480e2456a09bd1bbbc392cc93a31f83676730f3bbc3277b3b65ac0abca0501ce22f0a7f981d9ee0a5311b20e7b828f0c33d51be7aef3d7f29c7b7e5f7d7d664c987b5e54e775e00551da7b88026311b549e1b4067a6871a0889e139404c8aceeec58394cd51269d59800d261f63e7bc5daac88bc1c977d6db120757bcd0f5ea2d3b510759b7124acf449372f1ffe7cf1c88368f72bf1876b6f334bc1e90e2c3c6a6270b9989b99c8407c9e92e87275bf15880cf0e622ad15c6e79b53397c4ba4eacf6438e76120d10d70351bc1ce440bab971bc4b8fea5fb21b43c3eb77182b59d04bd47d2c41427c4f1540d34e553a28f0e1274b56172ff131743165f18d17ff748552bcf1da5dbea46af024e9d48b6cdd5669129356c795ac43132d02d66a23e9dd81fd761f4e5939afbac7038eaedb57fbdec19722df2fc7eaabe20076c1aa2fec38e401c48798053df3adbece15fb34b5ad6630f15536dc96d89afff17804d39d71dc074e50ed5bdabf774050ff979fc21e6f6ac673b3bc27fcff14b81dc6e8a377e8c82a2617cc4808a6eeab86efb1a6fcad8e58658bed469399ddca2b9452b78d96bd9ac12466cb07fa23c221b367bca12d4bf894ff080522fbefcc81920ac6b53ffabe32dcb21f009fa5348bc4889e70cfb8949ee3415d929f377cf2e0eb7e5c7e97faeaa097040d3cb46b74f8a6fb5dc045034d35ee2acc35e56e93a1b5545adfa2e137353377688be36e0aa3aa836e64dcd22551d3ddd9505b8f0b5564be70167b6ac16302d22648814904cd58d86b6a51f7e2e0301bb494edce9b6477622635c2c734dee3d218fc23e9487fe7d0b55b98bc70ec0095f8f7e487f9a8d61455a9996bf13e4e0fd84eace57aef022b7eced90671fd65e42f7e142ff7aaf39f55b02bbb0fe233a6c43299fb31308ca46176e6229b4dd49f3d660b8398d6b8c1457f4addb20b0f51f8786d1b34980bd6f340a9e68ede469ff80565705abb5ab19a3a1a9fbebae8620cb5d2a23a1ab5a35e221da8f8a681d55dc4132589d107d48e6432899ffd172bdbdb849b53c53413d121d1816136549896a7dc3c4650293b114330de6670d6c39dd85321b4dee5940c8fc969893fe8eaf7dbd6fe77c29ba24319784002d27d28b91e8b8dbafe416e6904c87e5151b2ad69b75e08fa22c0d8663071f3136fb2307a7ad3f7256122b16aebdf264cb395c5bb3bf1955d28fc37834d0f62bc5ba93653989a409bf8890fca3b0c7834d205e7848f9f7cea15fb786523f9ed0f405e781db5e2de1cb56ece455be6b2a6684ec260fa341a2e73d208df54d6a01504d09692099a6a8ac3bd5e57d569069d1eec0424aa895d5a3caf720b26b010a09d20ea5c8eb908a61e63681b43072d73479637a742798ea72dc77b816f591f3717a59c79119a0e47571a0e358544c3239edf3ac529c64263f65ae0e2146bba825a5ffe88f8a29884eb639dc8b097af8345a1072b27f3c3a367f067b9c2514dd585b28199194a2b3d0b36b3caf0088572047077b45b76cfafd0319bc22b8b8921f622747e819dd5dbe10d8a1239c93de8b13b8a536ccdd559f7203a3311fe1ee792fd442a70958b8e79e89f8bdee36454b1c615244ec843854ceb8f133d9acabd57400ec8c16a48d9739579814037af59ace1e4b5abf1c48d5fee8419c6095293042ea926cdc291166130f4f553f6a9cced619a39363e658a8335f21d854d14f8c93c60f768af3aafc463df8b1b4b33bb4af291736c62202e9980e6f39bd43911afd5f202d652bf62f5326901f0740194842b02e0324453cfa9f6d75ce169c2a44a468982f486d7860d54ee74f215c0b7518020ba04290b89aa30e099ed9e06643193afae32a0a121d10b9276e1f8c2b4503dc5129541863a7e0e2d30500472bf750ac2663bc5e9b8ae165355ad4add78dc510a56245b263ab35f7afcb9caff6d3050a7aad1865649bf4b31417e167212a9485e0fc67a1008c955e930ad5b4f67c35921c95f26919db276af44fcd1502cc0f9e57e765e8bb20338e9995e77a8b957401481e0d5aa79e38a111a39ff93a5d9e572118e6c90965a4c9a62a6cd195bd6dc79b42b99c1de7a9f78365393657dde3d45957048df84f7815e63f046e63e3fbd3100119885c3398b1425e5b7871d4301600bd42b2e159d4d3644c52f476251db0e24bbd89a35159ffd3c16f62c3cda9bfb0339e192b3c8caad188b22de7ea48063ad569388f4762fe23bf91be97f0c29c17d5b8ec08d75767f2cd05b8d2078e6540d4db397019a76234179c9f6a5777259eec67f3cb50d32e0ef9ab27bc1bd8cb0a28e1acad497706f59d7cf9044aa71f54e8d963421aa6eb7033b6659de71c41898b9a9fd129e4095d0276c513c50b00445a3cedd587b8090dcfb0f9b35bc7100ae37486e99c731bd55100666179059253271ec931e509fab60919430d72929962f7877b236925fa98988223eb88263fba3f0a897692dff35643d1ea9e1b0dba0287021ee8d54172d5b2fc72b74fc2cacd8de5300f4cdc601ed803258db71a5f375ac6adda5394bb13d3c856c2448bd4f6658c0cde299ac8963e62aa9fd34ce35d6c178e63fea497ee702893d4218a810cf5a4cdd34adabf9835fc6feb53a59ffd02fddc2447e7ba789a80a235618ff8c2db6eda0c8bcb5f2ddaa60da9bfc44b936f3fbe180ac41eea0f68d23da353f1b9d14f5cd36a8dd23bbffd187008ef13d8e8c90361363458223304ab001c89ca5e32da789b695f8809604fcf5eac79bd6feb4386ca96dedf5f77f1286550ff926495ad6d0bc79fe8088478b624ad54efa13f4cd1f14ad690698732a25eedb206211950255ab41957e24a261ee8f2fbac3012212ba7076a5a2fc899fa19d4acd0b2e9463fbe56e6e41d2229d896383bfa6341e4bc69fcd2e1e4328525f04a1c3a15f0c6c7c9ecba87d949c9f4a1a0a34479b9052f6d3a512cce385e34ffdc534dffb907ba1ee0bbd2c0c48cd0d2c6dbeb5bff3f5724e08a040355f4f32eef12c686ceb782f30860916ef74434e882c1ee98be9e6e70acc107f004cec5326b0ffecd4853df59e3c52952133280a1e383b698a4a65d404140a70606689875985cce8cee70f59cef602b622596299d8a3b7c59bfef805699371a3b346be3a7b030d68903fa4f2512f1ce78230e0559775c4734fe7d9db74fd4a82e946e6aa3460f8cd6e6630dd17de352d02d4fe6b9f36d5be09f395bc2bbffb68082f53d677823986882179b828c002f5e5b1a8f7c34eb7ad54d1e48e3bb3f3cc93de097ca429e74b280da282f150b3e84721ad24771206d82394e9ac6cfce85490a192176bfb13be0d21b64593da20dce4574bfbead80fd065544548c0a56b9ffcaf3d524e9c0ca04889d0e8df0518347f897b4fe4384eddcc642f7bf27445d2584c957cb63351a98b328f6b310472b77c86333d76c91c9fe5dd47fea1412f63b2079927548aaac76ca015ffaa5e0f3d757bdb8c3f7aa9344666e22c846f71c5598ea84f2371b8823dd6c8f3bc46eceb9ac0c84402a45062beae7c9d41a0f667dbc0b1cd742545f60a61815e79a37bce6e423dfd2a0b245a2998b134f6c0aa96fb30ed0d0569d0b3a7d44c3db4468a9c306d7df554510714792124eab0ce465fc30e1786a4263c1f8356133b47c54cacc238070126a5966acbdbf46f3798cae7ed8b7be5ffac2aee1165cd8f826be4fea6e9257f3203dd122ddf6f83a42ef2ba3d9d6f86e80f0997543be37af2a8c635ec5d15e7787b4e702279b9b28e7aeec4e6e297e59b2b9e5e901a28ab1c3ab8745e6e4a8bf82387fab52d4fdd23fc5d4a3041fc36190c081fa3142cfb755b2e4d1e31d161cb05b62fc29578ba4c79604576c4a85f19a224f308d3ceb77c0901263279b633dda5822111b98972a41ec4890751f9a27f6e2422383d09e78a63c4d21feabb3ec2db4ecfbeccd7b1257051f0623803358f5694ad51f06a6ad1e2e7a4986bc8a46eb7d1efb340d7a03626b855e1b189838f5dc1a775f565cab5a3439491ecb3120db6b784507efd11d5cb7f5537b101ba45fd482802d48cb0bb4f33fa1ae8bcc98ce2e3f273542f887574dca27ea20b27a591c0ecebf2045549648474026fc557b2bf90ee610e213f4a9a6f5702b10e959c13fff6d36d87d4c0b51ea87e6321050711edf158b68fedbe492cca677b4d363a795de424d0c1a4cb361495ddac0605fef20b990d9d557d34564f7120c8f3524a6dae9035fba75e5b4f2492433beccf268eb693d0c6b454a24e8cf316175ddb9971b3497bec0e9b5669d3d16e3b9a8d7df3f9afa2cbfd7d223630c765698687a97a02c91ae99a9de4bbf15d1313724d79535e4345a70ca00cef537001d3168c56c998eacc1a522cff6ab83ee76e718f9581447a1fbd71b57142b512b9004f74a53c5bd25014afb329dd5dfb7f964b9273722fdfc83382f5ea53fcc7a35b8db48edaa14657c7be0410ec3d1d6d3b3af7b32249a8ae49b2ba03ed85434fd8ee27a2b0746103b5bfa8f4adf46133b44b47ece5a8576abc6a870d7d599585c02f1cc04bff11648204664710685e68e4e58c8a36975f9ece014572a1c755474f1c4a151601913bf847fe72d56f0fb2f8dc483a120f15ab3e923f1f9de12db57a70960d6a77355af7b9a721c4111a60b347b169c5954f61388be2b862eeb4f1b447aa23e36cf29b4046a013feae78c9ac2667a824485becf4090d7df8eed9a73881cfd85ca75d65ad3d322a6cab07d0672806191a580b33590eb75e9b1decbfc06dd1eb3b405b7f63c31a75b5a4561322d50403de8794cb51cf7b255afcecb688f40c1457e282fae99d7c12ec8c726dd35218cdbadae27bf3dbfe88e007eb3086223a5100966e5deb048884c8cb00a6e08244fb0c0373175583ea16b7690c8177fbf75cfef6f70871d2282989402bd5183acec88a80e8939264d317c68030b81e9834cbe7e9c41f77c98e274cff2241d4a0fc6fd18487b31a776c7a3553d04edb2d7c3e98e076df7e18acff3745c92fb888ee51928141121460edbfbb17dd14ae39332c3b16a6b2415ef7a0200651ce5fa98d2f4b585d2360cdac13e058009744e3e83eb13bd02679e2a23d006ea0a1c1f2510691aaab5c55c697205c98b90fe70dd44a142aab1613cb1e7c6579d58124288dbd7303cffb38b0ecbe852e902e74b59e1c98a8ba72dd6d13ee024ebc47bb747d9f5d8e1adf7098f15653825ffd2054a313ef2fe4c3755113a62201a6ae2d74b3f17a7eaee58d578edf6cf7080ec53b48fcb4aeda1968def9c866ce617ce81bb5f76690b8e67a96157914323e03380782d8a8b6bfd6ca9a9fc7f33535f07b3ab0b1cea8e440e4753b1e0de953f375f71e63f4becc764a65fa71ed134563bf58841e941d5c332a53d94dae3c8556df49a8b3e5fa3a74ee05267960ac76cc977229a3f3d18bda5a8e59da00a821f43727dc70be4be30071f9b9ce2043d25390ba4ded604bf91516dd08fed1d22bbf9f29b812a2e4131491760005c1c369bc9c91ea514444a0d53e563f2a4e214ccba137aec32005a02a7f023dce7088c453230faf55b1dbb5adc66964a2f28c98d0d181b106a5d6f360780d66a7db89962359bed6c7410216277e1316060195b076bc7d793441d14960869770eba63c28b3d56c4da9e2336554bb0be2f0f0081fec62748e957d0fdb2efaaeda7cabef6f01763daadd97565713844eb608620dafe872cb52c384d59fc708a1b478583d4aa49fdb8bcad05f197889f62710e7fccd3cb4ee152b0c70cd5b10e615a11aee3cedba5b7f80185145f86d8a7f144909966c38a99d9331e0835e8e81c64441c228d7be9035ba1c939500a57deeb80bded1e9b3078773d965e873880a44730373784b1d29d40a153fcaf194b7e43191a5bc8881c28cae66cd1241a6e4814dc2d481e26a720dffa9e7d980e6b65aa4aacf49c0383f263c0d6f519267b911677c0537bcb74c686d47e800d58f0867395a9e597d47934c754ae9bb3ad4caf21da165a8833b99fcb4464666fb4dec1de042b9f966230aabd6d76f84c9106c734efdd50cc519f7bd4d9c83ed555c37fa8f2ceb638e4b0958e9fe746c8fbd8c107af401a6c60c6112c795b01cf32ec38653ea7f475156f83f965674b0507eea97fd60bccd76a719e211808ec4047c00bd12fb89990f0ee35be1784ef9f7c3626a1b60def944df82752d702c77090994a12557d7219ef62072000fb590a9373678eb41401551b40c1c2aed803aa840fa620c5a08d1d891f8b302731bb3649e3e1315709259fe4e2f9cda47d943a1a023fd4de5bd412f4e182d23ebb3bd9c46f4c1134054969553f3c621b37b3182878f55cb2ebcd4cf436dbdfb3bcdcae9a7ca0a0bf80f4ef7ee4dd9049aeaad697921c37ab1789295b3de98e2c002481549ba3e02595f420b4b54c6c9ec63bbbe8a492a9053077c8153cde915d59623be7c2f0e26b6c821e81f3509dd400156966c08465e07d68c427e629bc962ca5745707f349b11b908e485918ea19f28f157ee9433e72ae070f24af893be726abd93e43a7478af371c9759ed90f4d084c712cd7d8917563271e3061110b52424e5b96d12f5a04684fa2aaacaf7279b53461d863aad8097b31b1a3be490c633afbb371df8279242c83448bbe3fce500bc5de32da939365014ef2be3842022214c410022a00101ee86ac70f33b65c846a094a2bff940356a3d4fba01f2f39ff8c97f13e0179b1dc51ae2eb2810dce52ac9b91bd82ab6be07651bc003b73fb5702a5e27c3c7865fd0dea0ae72e553af22a2e3a28b954d2726a4e3724cc2fba0d62ec54121892f978283b3812e1eeab648207f1530e1da2eee112deed615ca1ca15216a48cddb3595d24d8f526d4b39ea15bcd1cb1ebf02cf336e6fd3dffa66ce0dc772d0173a9529f24ab0f8f1a5fcd9a0c102c47f16e22e5b77c603adfe4bde0ec131bb9b2dadee33511b6a13299f6b4510e79e887e417df5045e769dd408d3b51043a9d56ce0ffcb761d01b5e58c90dce900621ffa1d3b652c4736c6fe71876300cfeb1397a3de8e31f6a560ff29dd633d102954db88e1c13d40fedc4347f8bb147fb22744cef501ecca976a91d4f7f8955f664c63251771db60af7b1dbbd76d115f363f86e4982c782ff2eef8385f37f7e383326e77d25ab441de7a040b8f0d9561f45650838e078a8660558a81f38f6e0d56919678f29978cebbed81d0285b4d7e6981be518010131e31a2119c96837265a3f512f69976b24e3b05a0781f2feefcfd926b4ece3d0389756d599e82e1657ed26b60928949ef4b2d149f1605c90b7f99b91ef0729795c5d54d1d9bf1711fbe1edc3d775cfc6798c374dbc8a7565a100cf178fd58a759d2cf5e2a8169e7864d48552af82ca2060a9d6a4408350bdc51817c53c33d6faca6b2c56bda1102c94c162b10211ba0b1793f0e7cf0dcf0563c8c268d9d2764dba964e9d31421fa0ec1706b95c98efd45813d4308a4442f3fdc7b16bfdbe70801de32f1509daf9f2cf96c581222c5d9766bd11c94539dc85f75566729f849dba3a8c7b4bbb45c96e67e347c9c8c1fc6efe2dfcc9b65eedf8fcb142d192f983a87e53ffaccbf585d7eb907388e8f1ebe54e679ca981de26adce5dc9146522d25058af500d0421215e4be2b29fa0e199cf6638ef7e52a01865627f079e7116c7f346610e526681cc9544501eba289316eb846a44c47f7746d0973a6fbf931c874fb9514fd852c5ef1e896f49ef078fd9593582bce0baa7506b05cc234284dabaccb7aac7f8e31f84b6a1514a6332252c12cc3237812efd5bc5e0edb48081acf80833ba40f9683fb192d134c78b6a5c413cda10a08be4ff71b34d56bee77cc7cbd1e4b0845d39e8af796c36b241c2e8a7e57696cdf68207f12ee1f171c56f132d084f3e228d1c4249ff4071ddf9e6e271d51b98b803b86c74d136ae2331da63d8c6f90d66c1341ae252fff010ee53e60282f3ffa802406c8680d7ea2aa1b6983f670b84caa129b8e640ad6a38dc7c4017dfcddc2d7d996a553b65849499391255ef25bf3a0d78a584a7c5dc41f81e784ad03b007dd8758c0147caf7260a7d7889afd871f8f58ce98dcf4ace66c8c5150cec1fe5ccb348ffe7efb90e25eb17600317adfc5067d78f6db3c10705cb58ea2b1926a442dfd92eb8f086cb49541e82eb3002121a7ca34e5348179f2f4e614e4b1d9541b8523c4abb69b6b3535189be000c52a26c1eb5bd3d4d70736f7541f4d3041675574878032874d76b3cd5eca35203bc55c3266fb3ff11f6613454c45a0d6ad10b9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5a5070a1f898b3eb7ca64bfa9752f7cf"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const {isSuccessful} = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIgIGZpbGw9IiNGRkZGRkYiLz48L3N2Zz4=";
    const imgSrcEyeOpened =
        //Black
        //"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        //White
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiICBmaWxsPSIjRkZGRkZGIi8+PC9zdmc+";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const {isSuccessful} = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
